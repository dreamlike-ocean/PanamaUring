// Generated by jextract

package top.dreamlike.nativeLib.liburing;

import top.dreamlike.helper.NativeHelper;

import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

import static java.lang.foreign.ValueLayout.*;
public class liburing_h extends liburing_h_1 {

    /* package-private */ liburing_h() {}
    public static OfByte C_CHAR = Constants$root.C_CHAR$LAYOUT;
    public static OfShort C_SHORT = Constants$root.C_SHORT$LAYOUT;
    public static OfInt C_INT = Constants$root.C_INT$LAYOUT;
    public static OfLong C_LONG = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong C_LONG_LONG = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfFloat C_FLOAT = Constants$root.C_FLOAT$LAYOUT;
    public static OfDouble C_DOUBLE = Constants$root.C_DOUBLE$LAYOUT;
    public static OfAddress C_POINTER = Constants$root.C_POINTER$LAYOUT;
    public static int _XOPEN_SOURCE() {
        return (int)500L;
    }
    public static int _SYS_SOCKET_H() {
        return (int)1L;
    }
    public static int _FEATURES_H() {
        return (int)1L;
    }
    public static int __GLIBC_USE_ISOC2X() {
        return (int)0L;
    }
    public static int __USE_ISOC11() {
        return (int)1L;
    }
    public static int __USE_ISOC99() {
        return (int)1L;
    }
    public static int __USE_ISOC95() {
        return (int)1L;
    }
    public static int _POSIX_SOURCE() {
        return (int)1L;
    }
    public static int __USE_POSIX_IMPLICITLY() {
        return (int)1L;
    }
    public static int __USE_POSIX() {
        return (int)1L;
    }
    public static int __USE_POSIX2() {
        return (int)1L;
    }
    public static int __USE_POSIX199309() {
        return (int)1L;
    }
    public static int __USE_POSIX199506() {
        return (int)1L;
    }
    public static int __USE_XOPEN() {
        return (int)1L;
    }
    public static int __USE_XOPEN_EXTENDED() {
        return (int)1L;
    }
    public static int __USE_UNIX98() {
        return (int)1L;
    }
    public static int _LARGEFILE_SOURCE() {
        return (int)1L;
    }
    public static int __USE_LARGEFILE() {
        return (int)1L;
    }
    public static int __USE_FORTIFY_LEVEL() {
        return (int)0L;
    }
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return (int)0L;
    }
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return (int)0L;
    }
    public static int _STDC_PREDEF_H() {
        return (int)1L;
    }
    public static int __STDC_IEC_559__() {
        return (int)1L;
    }
    public static int __STDC_IEC_559_COMPLEX__() {
        return (int)1L;
    }
    public static int __GNU_LIBRARY__() {
        return (int)6L;
    }
    public static int __GLIBC__() {
        return (int)2L;
    }
    public static int __GLIBC_MINOR__() {
        return (int)31L;
    }
    public static int _SYS_CDEFS_H() {
        return (int)1L;
    }
    public static int __glibc_c99_flexarr_available() {
        return (int)1L;
    }
    public static int __WORDSIZE() {
        return (int)64L;
    }
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return (int)1L;
    }
    public static int __SYSCALL_WORDSIZE() {
        return (int)64L;
    }
    public static int __LONG_DOUBLE_USES_FLOAT128() {
        return (int)0L;
    }
    public static int __HAVE_GENERIC_SELECTION() {
        return (int)1L;
    }
    public static int __iovec_defined() {
        return (int)1L;
    }
    public static int _SYS_TYPES_H() {
        return (int)1L;
    }
    public static int _BITS_TYPES_H() {
        return (int)1L;
    }
    public static int _BITS_TYPESIZES_H() {
        return (int)1L;
    }
    public static int __OFF_T_MATCHES_OFF64_T() {
        return (int)1L;
    }
    public static int __INO_T_MATCHES_INO64_T() {
        return (int)1L;
    }
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return (int)1L;
    }
    public static int __STATFS_MATCHES_STATFS64() {
        return (int)1L;
    }
    public static int __FD_SETSIZE() {
        return (int)1024L;
    }
    public static int _BITS_TIME64_H() {
        return (int)1L;
    }
    public static int __clock_t_defined() {
        return (int)1L;
    }
    public static int __clockid_t_defined() {
        return (int)1L;
    }
    public static int __time_t_defined() {
        return (int)1L;
    }
    public static int __timer_t_defined() {
        return (int)1L;
    }
    public static int _BITS_STDINT_INTN_H() {
        return (int)1L;
    }
    public static int __BIT_TYPES_DEFINED__() {
        return (int)1L;
    }
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return (int)1L;
    }
    public static int _THREAD_SHARED_TYPES_H() {
        return (int)1L;
    }
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return (int)1L;
    }
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return (int)40L;
    }
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return (int)56L;
    }
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return (int)56L;
    }
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return (int)32L;
    }
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return (int)4L;
    }
    public static int __SIZEOF_PTHREAD_COND_T() {
        return (int)48L;
    }
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return (int)4L;
    }
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return (int)8L;
    }
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return (int)4L;
    }
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return (int)1L;
    }
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return (int)1L;
    }
    public static int __have_pthread_attr_t() {
        return (int)1L;
    }
    public static int PF_UNSPEC() {
        return (int)0L;
    }
    public static int PF_LOCAL() {
        return (int)1L;
    }
    public static int PF_INET() {
        return (int)2L;
    }
    public static int PF_AX25() {
        return (int)3L;
    }
    public static int PF_IPX() {
        return (int)4L;
    }
    public static int PF_APPLETALK() {
        return (int)5L;
    }
    public static int PF_NETROM() {
        return (int)6L;
    }
    public static int PF_BRIDGE() {
        return (int)7L;
    }
    public static int PF_ATMPVC() {
        return (int)8L;
    }
    public static int PF_X25() {
        return (int)9L;
    }
    public static int PF_INET6() {
        return (int)10L;
    }
    public static int PF_ROSE() {
        return (int)11L;
    }
    public static int PF_DECnet() {
        return (int)12L;
    }
    public static int PF_NETBEUI() {
        return (int)13L;
    }
    public static int PF_SECURITY() {
        return (int)14L;
    }
    public static int PF_KEY() {
        return (int)15L;
    }
    public static int PF_NETLINK() {
        return (int)16L;
    }
    public static int PF_PACKET() {
        return (int)17L;
    }
    public static int PF_ASH() {
        return (int)18L;
    }
    public static int PF_ECONET() {
        return (int)19L;
    }
    public static int PF_ATMSVC() {
        return (int)20L;
    }
    public static int PF_RDS() {
        return (int)21L;
    }
    public static int PF_SNA() {
        return (int)22L;
    }
    public static int PF_IRDA() {
        return (int)23L;
    }
    public static int PF_PPPOX() {
        return (int)24L;
    }
    public static int PF_WANPIPE() {
        return (int)25L;
    }
    public static int PF_LLC() {
        return (int)26L;
    }
    public static int PF_IB() {
        return (int)27L;
    }
    public static int PF_MPLS() {
        return (int)28L;
    }
    public static int PF_CAN() {
        return (int)29L;
    }
    public static int PF_TIPC() {
        return (int)30L;
    }
    public static int PF_BLUETOOTH() {
        return (int)31L;
    }
    public static int PF_IUCV() {
        return (int)32L;
    }
    public static int PF_RXRPC() {
        return (int)33L;
    }
    public static int PF_ISDN() {
        return (int)34L;
    }
    public static int PF_PHONET() {
        return (int)35L;
    }
    public static int PF_IEEE802154() {
        return (int)36L;
    }
    public static int PF_CAIF() {
        return (int)37L;
    }
    public static int PF_ALG() {
        return (int)38L;
    }
    public static int PF_NFC() {
        return (int)39L;
    }
    public static int PF_VSOCK() {
        return (int)40L;
    }
    public static int PF_KCM() {
        return (int)41L;
    }
    public static int PF_QIPCRTR() {
        return (int)42L;
    }
    public static int PF_SMC() {
        return (int)43L;
    }
    public static int PF_XDP() {
        return (int)44L;
    }
    public static int PF_MAX() {
        return (int)45L;
    }
    public static int SOL_RAW() {
        return (int)255L;
    }
    public static int SOL_DECNET() {
        return (int)261L;
    }
    public static int SOL_X25() {
        return (int)262L;
    }
    public static int SOL_PACKET() {
        return (int)263L;
    }
    public static int SOL_ATM() {
        return (int)264L;
    }
    public static int SOL_AAL() {
        return (int)265L;
    }
    public static int SOL_IRDA() {
        return (int)266L;
    }
    public static int SOL_NETBEUI() {
        return (int)267L;
    }
    public static int SOL_LLC() {
        return (int)268L;
    }
    public static int SOL_DCCP() {
        return (int)269L;
    }
    public static int SOL_NETLINK() {
        return (int)270L;
    }
    public static int SOL_TIPC() {
        return (int)271L;
    }
    public static int SOL_RXRPC() {
        return (int)272L;
    }
    public static int SOL_PPPOL2TP() {
        return (int)273L;
    }
    public static int SOL_BLUETOOTH() {
        return (int)274L;
    }
    public static int SOL_PNPIPE() {
        return (int)275L;
    }
    public static int SOL_RDS() {
        return (int)276L;
    }
    public static int SOL_IUCV() {
        return (int)277L;
    }
    public static int SOL_CAIF() {
        return (int)278L;
    }
    public static int SOL_ALG() {
        return (int)279L;
    }
    public static int SOL_NFC() {
        return (int)280L;
    }
    public static int SOL_KCM() {
        return (int)281L;
    }
    public static int SOL_TLS() {
        return (int)282L;
    }
    public static int SOL_XDP() {
        return (int)283L;
    }
    public static int SOMAXCONN() {
        return (int)4096L;
    }
    public static int _BITS_SOCKADDR_H() {
        return (int)1L;
    }
    public static int _SS_SIZE() {
        return (int)128L;
    }
    public static int SO_DEBUG() {
        return (int)1L;
    }
    public static int SOL_SOCKET() {
        return (int)1L;
    }
    public static int SO_ACCEPTCONN() {
        return (int)30L;
    }
    public static int SO_BROADCAST() {
        return (int)6L;
    }
    public static int SO_DONTROUTE() {
        return (int)5L;
    }
    public static int SO_ERROR() {
        return (int)4L;
    }
    public static int SO_KEEPALIVE() {
        return (int)9L;
    }
    public static int SO_LINGER() {
        return (int)13L;
    }
    public static int SO_OOBINLINE() {
        return (int)10L;
    }
    public static int SO_RCVBUF() {
        return (int)8L;
    }
    public static int SO_RCVLOWAT() {
        return (int)18L;
    }
    public static int SO_RCVTIMEO() {
        return (int)20L;
    }
    public static int SO_REUSEADDR() {
        return (int)2L;
    }
    public static int SO_SNDBUF() {
        return (int)7L;
    }
    public static int SO_SNDLOWAT() {
        return (int)19L;
    }
    public static int SO_SNDTIMEO() {
        return (int)21L;
    }
    public static int SO_TYPE() {
        return (int)3L;
    }
    public static int _SYS_UIO_H() {
        return (int)1L;
    }
    public static int _BITS_UIO_LIM_H() {
        return (int)1L;
    }
    public static int __IOV_MAX() {
        return (int)1024L;
    }
    public static int _SYS_STAT_H() {
        return (int)1L;
    }
    public static int _BITS_STAT_H() {
        return (int)1L;
    }
    public static int _STAT_VER_KERNEL() {
        return (int)0L;
    }
    public static int _STAT_VER_LINUX() {
        return (int)1L;
    }
    public static int _MKNOD_VER_LINUX() {
        return (int)0L;
    }
    public static int __S_IFMT() {
        return (int)61440L;
    }
    public static int __S_IFDIR() {
        return (int)16384L;
    }
    public static int __S_IFCHR() {
        return (int)8192L;
    }
    public static int __S_IFBLK() {
        return (int)24576L;
    }
    public static int __S_IFREG() {
        return (int)32768L;
    }
    public static int __S_IFIFO() {
        return (int)4096L;
    }
    public static int __S_IFLNK() {
        return (int)40960L;
    }
    public static int __S_IFSOCK() {
        return (int)49152L;
    }
    public static int __S_ISUID() {
        return (int)2048L;
    }
    public static int __S_ISGID() {
        return (int)1024L;
    }
    public static int __S_ISVTX() {
        return (int)512L;
    }
    public static int __S_IREAD() {
        return (int)256L;
    }
    public static int __S_IWRITE() {
        return (int)128L;
    }
    public static int __S_IEXEC() {
        return (int)64L;
    }
    public static int _MKNOD_VER() {
        return (int)0L;
    }
    public static int _ERRNO_H() {
        return (int)1L;
    }
    public static int _BITS_ERRNO_H() {
        return (int)1L;
    }
    public static int EPERM() {
        return (int)1L;
    }
    public static int ENOENT() {
        return (int)2L;
    }
    public static int ESRCH() {
        return (int)3L;
    }
    public static int EINTR() {
        return (int)4L;
    }
    public static int EIO() {
        return (int)5L;
    }
    public static int ENXIO() {
        return (int)6L;
    }
    public static int E2BIG() {
        return (int)7L;
    }
    public static int ENOEXEC() {
        return (int)8L;
    }
    public static int EBADF() {
        return (int)9L;
    }
    public static int ECHILD() {
        return (int)10L;
    }
    public static int EAGAIN() {
        return (int)11L;
    }
    public static int ENOMEM() {
        return (int)12L;
    }
    public static int EACCES() {
        return (int)13L;
    }
    public static int EFAULT() {
        return (int)14L;
    }
    public static int ENOTBLK() {
        return (int)15L;
    }
    public static int EBUSY() {
        return (int)16L;
    }
    public static int EEXIST() {
        return (int)17L;
    }
    public static int EXDEV() {
        return (int)18L;
    }
    public static int ENODEV() {
        return (int)19L;
    }
    public static int ENOTDIR() {
        return (int)20L;
    }
    public static int EISDIR() {
        return (int)21L;
    }
    public static int EINVAL() {
        return (int)22L;
    }
    public static int ENFILE() {
        return (int)23L;
    }
    public static int EMFILE() {
        return (int)24L;
    }
    public static int ENOTTY() {
        return (int)25L;
    }
    public static int ETXTBSY() {
        return (int)26L;
    }
    public static int EFBIG() {
        return (int)27L;
    }
    public static int ENOSPC() {
        return (int)28L;
    }
    public static int ESPIPE() {
        return (int)29L;
    }
    public static int EROFS() {
        return (int)30L;
    }
    public static int EMLINK() {
        return (int)31L;
    }
    public static int EPIPE() {
        return (int)32L;
    }
    public static int EDOM() {
        return (int)33L;
    }
    public static int ERANGE() {
        return (int)34L;
    }
    public static int EDEADLK() {
        return (int)35L;
    }
    public static int ENAMETOOLONG() {
        return (int)36L;
    }
    public static int ENOLCK() {
        return (int)37L;
    }
    public static int ENOSYS() {
        return (int)38L;
    }
    public static int ENOTEMPTY() {
        return (int)39L;
    }
    public static int ELOOP() {
        return (int)40L;
    }
    public static int ENOMSG() {
        return (int)42L;
    }
    public static int EIDRM() {
        return (int)43L;
    }
    public static int ECHRNG() {
        return (int)44L;
    }
    public static int EL2NSYNC() {
        return (int)45L;
    }
    public static int EL3HLT() {
        return (int)46L;
    }
    public static int EL3RST() {
        return (int)47L;
    }
    public static int ELNRNG() {
        return (int)48L;
    }
    public static int EUNATCH() {
        return (int)49L;
    }
    public static int ENOCSI() {
        return (int)50L;
    }
    public static int EL2HLT() {
        return (int)51L;
    }
    public static int EBADE() {
        return (int)52L;
    }
    public static int EBADR() {
        return (int)53L;
    }
    public static int EXFULL() {
        return (int)54L;
    }
    public static int ENOANO() {
        return (int)55L;
    }
    public static int EBADRQC() {
        return (int)56L;
    }
    public static int EBADSLT() {
        return (int)57L;
    }
    public static int EBFONT() {
        return (int)59L;
    }
    public static int ENOSTR() {
        return (int)60L;
    }
    public static int ENODATA() {
        return (int)61L;
    }
    public static int ETIME() {
        return (int)62L;
    }
    public static int ENOSR() {
        return (int)63L;
    }
    public static int ENONET() {
        return (int)64L;
    }
    public static int ENOPKG() {
        return (int)65L;
    }
    public static int EREMOTE() {
        return (int)66L;
    }
    public static int ENOLINK() {
        return (int)67L;
    }
    public static int EADV() {
        return (int)68L;
    }
    public static int ESRMNT() {
        return (int)69L;
    }
    public static int ECOMM() {
        return (int)70L;
    }
    public static int EPROTO() {
        return (int)71L;
    }
    public static int EMULTIHOP() {
        return (int)72L;
    }
    public static int EDOTDOT() {
        return (int)73L;
    }
    public static int EBADMSG() {
        return (int)74L;
    }
    public static int EOVERFLOW() {
        return (int)75L;
    }
    public static int ENOTUNIQ() {
        return (int)76L;
    }
    public static int EBADFD() {
        return (int)77L;
    }
    public static int EREMCHG() {
        return (int)78L;
    }
    public static int ELIBACC() {
        return (int)79L;
    }
    public static int ELIBBAD() {
        return (int)80L;
    }
    public static int ELIBSCN() {
        return (int)81L;
    }
    public static int ELIBMAX() {
        return (int)82L;
    }
    public static int ELIBEXEC() {
        return (int)83L;
    }
    public static int EILSEQ() {
        return (int)84L;
    }
    public static int ERESTART() {
        return (int)85L;
    }
    public static int ESTRPIPE() {
        return (int)86L;
    }
    public static int EUSERS() {
        return (int)87L;
    }
    public static int ENOTSOCK() {
        return (int)88L;
    }
    public static int EDESTADDRREQ() {
        return (int)89L;
    }
    public static int EMSGSIZE() {
        return (int)90L;
    }
    public static int EPROTOTYPE() {
        return (int)91L;
    }
    public static int ENOPROTOOPT() {
        return (int)92L;
    }
    public static int EPROTONOSUPPORT() {
        return (int)93L;
    }
    public static int ESOCKTNOSUPPORT() {
        return (int)94L;
    }
    public static int EOPNOTSUPP() {
        return (int)95L;
    }
    public static int EPFNOSUPPORT() {
        return (int)96L;
    }
    public static int EAFNOSUPPORT() {
        return (int)97L;
    }
    public static int EADDRINUSE() {
        return (int)98L;
    }
    public static int EADDRNOTAVAIL() {
        return (int)99L;
    }
    public static int ENETDOWN() {
        return (int)100L;
    }
    public static int ENETUNREACH() {
        return (int)101L;
    }
    public static int ENETRESET() {
        return (int)102L;
    }
    public static int ECONNABORTED() {
        return (int)103L;
    }
    public static int ECONNRESET() {
        return (int)104L;
    }
    public static int ENOBUFS() {
        return (int)105L;
    }
    public static int EISCONN() {
        return (int)106L;
    }
    public static int ENOTCONN() {
        return (int)107L;
    }
    public static int ESHUTDOWN() {
        return (int)108L;
    }
    public static int ETOOMANYREFS() {
        return (int)109L;
    }
    public static int ETIMEDOUT() {
        return (int)110L;
    }
    public static int ECONNREFUSED() {
        return (int)111L;
    }
    public static int EHOSTDOWN() {
        return (int)112L;
    }
    public static int EHOSTUNREACH() {
        return (int)113L;
    }
    public static int EALREADY() {
        return (int)114L;
    }
    public static int EINPROGRESS() {
        return (int)115L;
    }
    public static int ESTALE() {
        return (int)116L;
    }
    public static int EUCLEAN() {
        return (int)117L;
    }
    public static int ENOTNAM() {
        return (int)118L;
    }
    public static int ENAVAIL() {
        return (int)119L;
    }
    public static int EISNAM() {
        return (int)120L;
    }
    public static int EREMOTEIO() {
        return (int)121L;
    }
    public static int EDQUOT() {
        return (int)122L;
    }
    public static int ENOMEDIUM() {
        return (int)123L;
    }
    public static int EMEDIUMTYPE() {
        return (int)124L;
    }
    public static int ECANCELED() {
        return (int)125L;
    }
    public static int ENOKEY() {
        return (int)126L;
    }
    public static int EKEYEXPIRED() {
        return (int)127L;
    }
    public static int EKEYREVOKED() {
        return (int)128L;
    }
    public static int EKEYREJECTED() {
        return (int)129L;
    }
    public static int EOWNERDEAD() {
        return (int)130L;
    }
    public static int ENOTRECOVERABLE() {
        return (int)131L;
    }
    public static int ERFKILL() {
        return (int)132L;
    }
    public static int EHWPOISON() {
        return (int)133L;
    }
    public static int _BITS_SIGNUM_H() {
        return (int)1L;
    }
    public static int _BITS_SIGNUM_GENERIC_H() {
        return (int)1L;
    }
    public static int SIGINT() {
        return (int)2L;
    }
    public static int SIGILL() {
        return (int)4L;
    }
    public static int SIGABRT() {
        return (int)6L;
    }
    public static int SIGFPE() {
        return (int)8L;
    }
    public static int SIGSEGV() {
        return (int)11L;
    }
    public static int SIGTERM() {
        return (int)15L;
    }
    public static int SIGHUP() {
        return (int)1L;
    }
    public static int SIGQUIT() {
        return (int)3L;
    }
    public static int SIGTRAP() {
        return (int)5L;
    }
    public static int SIGKILL() {
        return (int)9L;
    }
    public static int SIGBUS() {
        return (int)10L;
    }
    public static int SIGSYS() {
        return (int)12L;
    }
    public static int SIGPIPE() {
        return (int)13L;
    }
    public static int SIGALRM() {
        return (int)14L;
    }
    public static int SIGURG() {
        return (int)16L;
    }
    public static int SIGSTOP() {
        return (int)17L;
    }
    public static int SIGTSTP() {
        return (int)18L;
    }
    public static int SIGCONT() {
        return (int)19L;
    }
    public static int SIGCHLD() {
        return (int)20L;
    }
    public static int SIGTTIN() {
        return (int)21L;
    }
    public static int SIGTTOU() {
        return (int)22L;
    }
    public static int SIGPOLL() {
        return (int)23L;
    }
    public static int SIGXCPU() {
        return (int)24L;
    }
    public static int SIGXFSZ() {
        return (int)25L;
    }
    public static int SIGVTALRM() {
        return (int)26L;
    }
    public static int SIGPROF() {
        return (int)27L;
    }
    public static int SIGUSR1() {
        return (int)30L;
    }
    public static int SIGUSR2() {
        return (int)31L;
    }
    public static int SIGWINCH() {
        return (int)28L;
    }
    public static int __SIGRTMIN() {
        return (int)32L;
    }
    public static int SIGSTKFLT() {
        return (int)16L;
    }
    public static int SIGPWR() {
        return (int)30L;
    }
    public static int __SIGRTMAX() {
        return (int)64L;
    }
    public static int __sig_atomic_t_defined() {
        return (int)1L;
    }
    public static int __sigset_t_defined() {
        return (int)1L;
    }
    public static int _STRUCT_TIMESPEC() {
        return (int)1L;
    }
    public static int _BITS_ENDIAN_H() {
        return (int)1L;
    }
    public static int __LITTLE_ENDIAN() {
        return (int)1234L;
    }
    public static int __BIG_ENDIAN() {
        return (int)4321L;
    }
    public static int __PDP_ENDIAN() {
        return (int)3412L;
    }
    public static int _BITS_ENDIANNESS_H() {
        return (int)1L;
    }
    public static int __siginfo_t_defined() {
        return (int)1L;
    }
    public static int __SI_MAX_SIZE() {
        return (int)128L;
    }
    public static int _BITS_SIGINFO_ARCH_H() {
        return (int)1L;
    }
    public static int __SI_ERRNO_THEN_CODE() {
        return (int)1L;
    }
    public static int __SI_HAVE_SIGSYS() {
        return (int)1L;
    }
    public static int _BITS_SIGINFO_CONSTS_H() {
        return (int)1L;
    }
    public static int __SI_ASYNCIO_AFTER_SIGIO() {
        return (int)1L;
    }
    public static int __sigevent_t_defined() {
        return (int)1L;
    }
    public static int __SIGEV_MAX_SIZE() {
        return (int)64L;
    }
    public static int _BITS_SIGEVENT_CONSTS_H() {
        return (int)1L;
    }
    public static int _BITS_SIGACTION_H() {
        return (int)1L;
    }
    public static int SA_NOCLDSTOP() {
        return (int)1L;
    }
    public static int SA_NOCLDWAIT() {
        return (int)2L;
    }
    public static int SA_SIGINFO() {
        return (int)4L;
    }
    public static int SA_ONSTACK() {
        return (int)134217728L;
    }
    public static int SA_RESTART() {
        return (int)268435456L;
    }
    public static int SA_NODEFER() {
        return (int)1073741824L;
    }
    public static int SIG_BLOCK() {
        return (int)0L;
    }
    public static int SIG_UNBLOCK() {
        return (int)1L;
    }
    public static int SIG_SETMASK() {
        return (int)2L;
    }
    public static int __stack_t_defined() {
        return (int)1L;
    }
    public static int _SYS_UCONTEXT_H() {
        return (int)1L;
    }
    public static int __NGREG() {
        return (int)23L;
    }
    public static int _BITS_SIGSTACK_H() {
        return (int)1L;
    }
    public static int MINSIGSTKSZ() {
        return (int)2048L;
    }
    public static int SIGSTKSZ() {
        return (int)8192L;
    }
    public static int _BITS_SS_FLAGS_H() {
        return (int)1L;
    }
    public static int __sigstack_defined() {
        return (int)1L;
    }
    public static int _BITS_SIGTHREAD_H() {
        return (int)1L;
    }
    public static int true_() {
        return (int)1L;
    }
    public static int false_() {
        return (int)0L;
    }
    public static int __bool_true_false_are_defined() {
        return (int)1L;
    }
    public static int _INTTYPES_H() {
        return (int)1L;
    }
    public static int _STDINT_H() {
        return (int)1L;
    }
    public static int __GLIBC_USE_LIB_EXT2() {
        return (int)0L;
    }
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return (int)0L;
    }
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return (int)0L;
    }
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return (int)0L;
    }
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return (int)0L;
    }
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return (int)0L;
    }
    public static int _BITS_WCHAR_H() {
        return (int)1L;
    }
    public static int _BITS_STDINT_UINTN_H() {
        return (int)1L;
    }
    public static int ____gwchar_t_defined() {
        return (int)1L;
    }
    public static int _TIME_H() {
        return (int)1L;
    }
    public static int _BITS_TIME_H() {
        return (int)1L;
    }
    public static int CLOCK_REALTIME() {
        return (int)0L;
    }
    public static int CLOCK_MONOTONIC() {
        return (int)1L;
    }
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return (int)2L;
    }
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return (int)3L;
    }
    public static int CLOCK_MONOTONIC_RAW() {
        return (int)4L;
    }
    public static int CLOCK_REALTIME_COARSE() {
        return (int)5L;
    }
    public static int CLOCK_MONOTONIC_COARSE() {
        return (int)6L;
    }
    public static int CLOCK_BOOTTIME() {
        return (int)7L;
    }
    public static int CLOCK_REALTIME_ALARM() {
        return (int)8L;
    }
    public static int CLOCK_BOOTTIME_ALARM() {
        return (int)9L;
    }
    public static int CLOCK_TAI() {
        return (int)11L;
    }
    public static int TIMER_ABSTIME() {
        return (int)1L;
    }
    public static int __struct_tm_defined() {
        return (int)1L;
    }
    public static int __itimerspec_defined() {
        return (int)1L;
    }
    public static int TIME_UTC() {
        return (int)1L;
    }
    public static int __BITS_PER_LONG() {
        return (int)64L;
    }
    public static int NR_OPEN() {
        return (int)1024L;
    }
    public static int NGROUPS_MAX() {
        return (int)65536L;
    }
    public static int ARG_MAX() {
        return (int)131072L;
    }
    public static int LINK_MAX() {
        return (int)127L;
    }
    public static int MAX_CANON() {
        return (int)255L;
    }
    public static int MAX_INPUT() {
        return (int)255L;
    }
    public static int NAME_MAX() {
        return (int)255L;
    }
    public static int PATH_MAX() {
        return (int)4096L;
    }
    public static int PIPE_BUF() {
        return (int)4096L;
    }
    public static int XATTR_NAME_MAX() {
        return (int)255L;
    }
    public static int XATTR_SIZE_MAX() {
        return (int)65536L;
    }
    public static int XATTR_LIST_MAX() {
        return (int)65536L;
    }
    public static int RTSIG_MAX() {
        return (int)32L;
    }
    public static int _IOC_NRBITS() {
        return (int)8L;
    }
    public static int _IOC_TYPEBITS() {
        return (int)8L;
    }
    public static int _IOC_SIZEBITS() {
        return (int)14L;
    }
    public static int _IOC_DIRBITS() {
        return (int)2L;
    }
    public static int _IOC_NRSHIFT() {
        return (int)0L;
    }
    public static int FSCRYPT_POLICY_FLAGS_PAD_4() {
        return (int)0L;
    }
    public static int FSCRYPT_POLICY_FLAGS_PAD_8() {
        return (int)1L;
    }
    public static int FSCRYPT_POLICY_FLAGS_PAD_16() {
        return (int)2L;
    }
    public static int FSCRYPT_POLICY_FLAGS_PAD_32() {
        return (int)3L;
    }
    public static int FSCRYPT_POLICY_FLAGS_PAD_MASK() {
        return (int)3L;
    }
    public static int FSCRYPT_POLICY_FLAG_DIRECT_KEY() {
        return (int)4L;
    }
    public static int FSCRYPT_MODE_AES_256_XTS() {
        return (int)1L;
    }
    public static int FSCRYPT_MODE_AES_256_CTS() {
        return (int)4L;
    }
    public static int FSCRYPT_MODE_AES_128_CBC() {
        return (int)5L;
    }
    public static int FSCRYPT_MODE_AES_128_CTS() {
        return (int)6L;
    }
    public static int FSCRYPT_MODE_ADIANTUM() {
        return (int)9L;
    }
    public static int FSCRYPT_POLICY_V1() {
        return (int)0L;
    }
    public static int FSCRYPT_KEY_DESCRIPTOR_SIZE() {
        return (int)8L;
    }
    public static int FSCRYPT_KEY_DESC_PREFIX_SIZE() {
        return (int)8L;
    }
    public static int FSCRYPT_MAX_KEY_SIZE() {
        return (int)64L;
    }
    public static int FSCRYPT_POLICY_V2() {
        return (int)2L;
    }
    public static int FSCRYPT_KEY_IDENTIFIER_SIZE() {
        return (int)16L;
    }
    public static int FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR() {
        return (int)1L;
    }
    public static int FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER() {
        return (int)2L;
    }
    public static int FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY() {
        return (int)1L;
    }
    public static int FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS() {
        return (int)2L;
    }
    public static int FSCRYPT_KEY_STATUS_ABSENT() {
        return (int)1L;
    }
    public static int FSCRYPT_KEY_STATUS_PRESENT() {
        return (int)2L;
    }
    public static int FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED() {
        return (int)3L;
    }
    public static int FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF() {
        return (int)1L;
    }
    public static int FS_POLICY_FLAGS_VALID() {
        return (int)7L;
    }
    public static int FS_ENCRYPTION_MODE_INVALID() {
        return (int)0L;
    }
    public static int FS_ENCRYPTION_MODE_AES_256_GCM() {
        return (int)2L;
    }
    public static int FS_ENCRYPTION_MODE_AES_256_CBC() {
        return (int)3L;
    }
    public static int FS_ENCRYPTION_MODE_SPECK128_256_XTS() {
        return (int)7L;
    }
    public static int FS_ENCRYPTION_MODE_SPECK128_256_CTS() {
        return (int)8L;
    }
    public static int MS_RDONLY() {
        return (int)1L;
    }
    public static int MS_NOSUID() {
        return (int)2L;
    }
    public static int MS_NODEV() {
        return (int)4L;
    }
    public static int MS_NOEXEC() {
        return (int)8L;
    }
    public static int MS_SYNCHRONOUS() {
        return (int)16L;
    }
    public static int MS_REMOUNT() {
        return (int)32L;
    }
    public static int MS_MANDLOCK() {
        return (int)64L;
    }
    public static int MS_DIRSYNC() {
        return (int)128L;
    }
    public static int MS_NOATIME() {
        return (int)1024L;
    }
    public static int MS_NODIRATIME() {
        return (int)2048L;
    }
    public static int MS_BIND() {
        return (int)4096L;
    }
    public static int MS_MOVE() {
        return (int)8192L;
    }
    public static int MS_REC() {
        return (int)16384L;
    }
    public static int MS_VERBOSE() {
        return (int)32768L;
    }
    public static int MS_SILENT() {
        return (int)32768L;
    }
    public static int OPEN_TREE_CLONE() {
        return (int)1L;
    }
    public static int MOVE_MOUNT_F_SYMLINKS() {
        return (int)1L;
    }
    public static int MOVE_MOUNT_F_AUTOMOUNTS() {
        return (int)2L;
    }
    public static int MOVE_MOUNT_F_EMPTY_PATH() {
        return (int)4L;
    }
    public static int MOVE_MOUNT_T_SYMLINKS() {
        return (int)16L;
    }
    public static int MOVE_MOUNT_T_AUTOMOUNTS() {
        return (int)32L;
    }
    public static int MOVE_MOUNT_T_EMPTY_PATH() {
        return (int)64L;
    }
    public static int MOVE_MOUNT__MASK() {
        return (int)119L;
    }
    public static int FSOPEN_CLOEXEC() {
        return (int)1L;
    }
    public static int FSPICK_CLOEXEC() {
        return (int)1L;
    }
    public static int FSPICK_SYMLINK_NOFOLLOW() {
        return (int)2L;
    }
    public static int FSPICK_NO_AUTOMOUNT() {
        return (int)4L;
    }
    public static int FSPICK_EMPTY_PATH() {
        return (int)8L;
    }
    public static int FSMOUNT_CLOEXEC() {
        return (int)1L;
    }
    public static int MOUNT_ATTR_RDONLY() {
        return (int)1L;
    }
    public static int MOUNT_ATTR_NOSUID() {
        return (int)2L;
    }
    public static int MOUNT_ATTR_NODEV() {
        return (int)4L;
    }
    public static int MOUNT_ATTR_NOEXEC() {
        return (int)8L;
    }
    public static int MOUNT_ATTR__ATIME() {
        return (int)112L;
    }
    public static int MOUNT_ATTR_RELATIME() {
        return (int)0L;
    }
    public static int MOUNT_ATTR_NOATIME() {
        return (int)16L;
    }
    public static int MOUNT_ATTR_STRICTATIME() {
        return (int)32L;
    }
    public static int MOUNT_ATTR_NODIRATIME() {
        return (int)128L;
    }
    public static int INR_OPEN_CUR() {
        return (int)1024L;
    }
    public static int INR_OPEN_MAX() {
        return (int)4096L;
    }
    public static int BLOCK_SIZE_BITS() {
        return (int)10L;
    }
    public static int SEEK_SET() {
        return (int)0L;
    }
    public static int SEEK_CUR() {
        return (int)1L;
    }
    public static int SEEK_END() {
        return (int)2L;
    }
    public static int SEEK_DATA() {
        return (int)3L;
    }
    public static int SEEK_HOLE() {
        return (int)4L;
    }
    public static int FILE_DEDUPE_RANGE_SAME() {
        return (int)0L;
    }
    public static int FILE_DEDUPE_RANGE_DIFFERS() {
        return (int)1L;
    }
    public static int NR_FILE() {
        return (int)8192L;
    }
    public static int FS_XFLAG_REALTIME() {
        return (int)1L;
    }
    public static int FS_XFLAG_PREALLOC() {
        return (int)2L;
    }
    public static int FS_XFLAG_IMMUTABLE() {
        return (int)8L;
    }
    public static int FS_XFLAG_APPEND() {
        return (int)16L;
    }
    public static int FS_XFLAG_SYNC() {
        return (int)32L;
    }
    public static int FS_XFLAG_NOATIME() {
        return (int)64L;
    }
    public static int FS_XFLAG_NODUMP() {
        return (int)128L;
    }
    public static int FS_XFLAG_RTINHERIT() {
        return (int)256L;
    }
    public static int FS_XFLAG_PROJINHERIT() {
        return (int)512L;
    }
    public static int FS_XFLAG_NOSYMLINKS() {
        return (int)1024L;
    }
    public static int FS_XFLAG_EXTSIZE() {
        return (int)2048L;
    }
    public static int FS_XFLAG_EXTSZINHERIT() {
        return (int)4096L;
    }
    public static int FS_XFLAG_NODEFRAG() {
        return (int)8192L;
    }
    public static int FS_XFLAG_FILESTREAM() {
        return (int)16384L;
    }
    public static int FS_XFLAG_DAX() {
        return (int)32768L;
    }
    public static int FS_XFLAG_COWEXTSIZE() {
        return (int)65536L;
    }
    public static int BMAP_IOCTL() {
        return (int)1L;
    }
    public static int FSLABEL_MAX() {
        return (int)256L;
    }
    public static int FS_SECRM_FL() {
        return (int)1L;
    }
    public static int FS_UNRM_FL() {
        return (int)2L;
    }
    public static int FS_COMPR_FL() {
        return (int)4L;
    }
    public static int FS_SYNC_FL() {
        return (int)8L;
    }
    public static int FS_IMMUTABLE_FL() {
        return (int)16L;
    }
    public static int FS_APPEND_FL() {
        return (int)32L;
    }
    public static int FS_NODUMP_FL() {
        return (int)64L;
    }
    public static int FS_NOATIME_FL() {
        return (int)128L;
    }
    public static int FS_DIRTY_FL() {
        return (int)256L;
    }
    public static int FS_COMPRBLK_FL() {
        return (int)512L;
    }
    public static int FS_NOCOMP_FL() {
        return (int)1024L;
    }
    public static int FS_ENCRYPT_FL() {
        return (int)2048L;
    }
    public static int FS_BTREE_FL() {
        return (int)4096L;
    }
    public static int FS_INDEX_FL() {
        return (int)4096L;
    }
    public static int FS_IMAGIC_FL() {
        return (int)8192L;
    }
    public static int FS_JOURNAL_DATA_FL() {
        return (int)16384L;
    }
    public static int FS_NOTAIL_FL() {
        return (int)32768L;
    }
    public static int FS_DIRSYNC_FL() {
        return (int)65536L;
    }
    public static int FS_TOPDIR_FL() {
        return (int)131072L;
    }
    public static int FS_HUGE_FILE_FL() {
        return (int)262144L;
    }
    public static int FS_EXTENT_FL() {
        return (int)524288L;
    }
    public static int FS_VERITY_FL() {
        return (int)1048576L;
    }
    public static int FS_EA_INODE_FL() {
        return (int)2097152L;
    }
    public static int FS_EOFBLOCKS_FL() {
        return (int)4194304L;
    }
    public static int FS_NOCOW_FL() {
        return (int)8388608L;
    }
    public static int FS_INLINE_DATA_FL() {
        return (int)268435456L;
    }
    public static int FS_PROJINHERIT_FL() {
        return (int)536870912L;
    }
    public static int FS_CASEFOLD_FL() {
        return (int)1073741824L;
    }
    public static int FS_FL_USER_VISIBLE() {
        return (int)253951L;
    }
    public static int FS_FL_USER_MODIFIABLE() {
        return (int)229631L;
    }
    public static int SYNC_FILE_RANGE_WAIT_BEFORE() {
        return (int)1L;
    }
    public static int SYNC_FILE_RANGE_WRITE() {
        return (int)2L;
    }
    public static int SYNC_FILE_RANGE_WAIT_AFTER() {
        return (int)4L;
    }
    public static OfShort __int16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfInt __int32_t = Constants$root.C_INT$LAYOUT;
    public static OfLong __int64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfShort __int_least16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfInt __int_least32_t = Constants$root.C_INT$LAYOUT;
    public static OfLong __int_least64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __quad_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __intmax_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __off_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __off64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __pid_t = Constants$root.C_INT$LAYOUT;
    public static OfLong __clock_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __time_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __suseconds_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __daddr_t = Constants$root.C_INT$LAYOUT;
    public static OfInt __key_t = Constants$root.C_INT$LAYOUT;
    public static OfInt __clockid_t = Constants$root.C_INT$LAYOUT;
    public static OfAddress __timer_t = Constants$root.C_POINTER$LAYOUT;
    public static OfLong __blksize_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __blkcnt_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __blkcnt64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __fsword_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __ssize_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __syscall_slong_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __loff_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfAddress __caddr_t = Constants$root.C_POINTER$LAYOUT;
    public static OfLong __intptr_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __sig_atomic_t = Constants$root.C_INT$LAYOUT;
    public static OfLong off_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt pid_t = Constants$root.C_INT$LAYOUT;
    public static OfLong ssize_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt key_t = Constants$root.C_INT$LAYOUT;
    public static OfLong clock_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt clockid_t = Constants$root.C_INT$LAYOUT;
    public static OfLong time_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfAddress timer_t = Constants$root.C_POINTER$LAYOUT;
    public static OfLong suseconds_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfShort int16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfInt int32_t = Constants$root.C_INT$LAYOUT;
    public static OfLong int64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong register_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong blksize_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong blkcnt_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt pthread_once_t = Constants$root.C_INT$LAYOUT;
    public static int SOCK_STREAM() {
        return (int)1L;
    }
    public static int SOCK_DGRAM() {
        return (int)2L;
    }
    public static int SOCK_RAW() {
        return (int)3L;
    }
    public static int SOCK_RDM() {
        return (int)4L;
    }
    public static int SOCK_SEQPACKET() {
        return (int)5L;
    }
    public static int SOCK_DCCP() {
        return (int)6L;
    }
    public static int SOCK_PACKET() {
        return (int)10L;
    }
    public static int SOCK_CLOEXEC() {
        return (int)524288L;
    }
    public static int SOCK_NONBLOCK() {
        return (int)2048L;
    }
    public static int MSG_OOB() {
        return (int)1L;
    }
    public static int MSG_PEEK() {
        return (int)2L;
    }
    public static int MSG_DONTROUTE() {
        return (int)4L;
    }
    public static int MSG_CTRUNC() {
        return (int)8L;
    }
    public static int MSG_PROXY() {
        return (int)16L;
    }
    public static int MSG_TRUNC() {
        return (int)32L;
    }
    public static int MSG_DONTWAIT() {
        return (int)64L;
    }
    public static int MSG_EOR() {
        return (int)128L;
    }
    public static int MSG_WAITALL() {
        return (int)256L;
    }
    public static int MSG_FIN() {
        return (int)512L;
    }
    public static int MSG_SYN() {
        return (int)1024L;
    }
    public static int MSG_CONFIRM() {
        return (int)2048L;
    }
    public static int MSG_RST() {
        return (int)4096L;
    }
    public static int MSG_ERRQUEUE() {
        return (int)8192L;
    }
    public static int MSG_NOSIGNAL() {
        return (int)16384L;
    }
    public static int MSG_MORE() {
        return (int)32768L;
    }
    public static int MSG_WAITFORONE() {
        return (int)65536L;
    }
    public static int MSG_BATCH() {
        return (int)262144L;
    }
    public static int MSG_ZEROCOPY() {
        return (int)67108864L;
    }
    public static int MSG_FASTOPEN() {
        return (int)536870912L;
    }
    public static int MSG_CMSG_CLOEXEC() {
        return (int)1073741824L;
    }
    public static MethodHandle __cmsg_nxthdr$MH() {
        return RuntimeHelper.requireNonNull(constants$0.__cmsg_nxthdr$MH,"__cmsg_nxthdr");
    }
    public static MemoryAddress __cmsg_nxthdr ( Addressable __mhdr,  Addressable __cmsg) {
        var mh$ = __cmsg_nxthdr$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__mhdr, __cmsg);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int SCM_RIGHTS() {
        return (int)1L;
    }
    public static int SHUT_RD() {
        return (int)0L;
    }
    public static int SHUT_WR() {
        return (int)1L;
    }
    public static int SHUT_RDWR() {
        return (int)2L;
    }
    public static MethodHandle socket$MH() {
        return RuntimeHelper.requireNonNull(constants$0.socket$MH,"socket");
    }
    public static int socket ( int __domain,  int __type,  int __protocol) {
        var mh$ = socket$MH();
        try {
            return (int)mh$.invokeExact(__domain, __type, __protocol);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle socketpair$MH() {
        return RuntimeHelper.requireNonNull(constants$0.socketpair$MH,"socketpair");
    }
    public static int socketpair ( int __domain,  int __type,  int __protocol,  Addressable __fds) {
        var mh$ = socketpair$MH();
        try {
            return (int)mh$.invokeExact(__domain, __type, __protocol, __fds);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle bind$MH() {
        return RuntimeHelper.requireNonNull(constants$0.bind$MH,"bind");
    }
    public static int bind ( int __fd,  Addressable __addr,  int __len) {
        var mh$ = bind$MH();
        try {
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getsockname$MH() {
        return RuntimeHelper.requireNonNull(constants$0.getsockname$MH,"getsockname");
    }
    public static int getsockname ( int __fd,  Addressable __addr,  Addressable __len) {
        var mh$ = getsockname$MH();
        try {
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle connect$MH() {
        return RuntimeHelper.requireNonNull(constants$0.connect$MH,"connect");
    }
    public static int connect ( int __fd,  Addressable __addr,  int __len) {
        var mh$ = connect$MH();
        try {
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getpeername$MH() {
        return RuntimeHelper.requireNonNull(constants$1.getpeername$MH,"getpeername");
    }
    public static int getpeername ( int __fd,  Addressable __addr,  Addressable __len) {
        var mh$ = getpeername$MH();
        try {
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle send$MH() {
        return RuntimeHelper.requireNonNull(constants$1.send$MH,"send");
    }
    public static long send ( int __fd,  Addressable __buf,  long __n,  int __flags) {
        var mh$ = send$MH();
        try {
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle recv$MH() {
        return RuntimeHelper.requireNonNull(constants$1.recv$MH,"recv");
    }
    public static long recv ( int __fd,  Addressable __buf,  long __n,  int __flags) {
        var mh$ = recv$MH();
        try {
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sendto$MH() {
        return RuntimeHelper.requireNonNull(constants$1.sendto$MH,"sendto");
    }
    public static long sendto ( int __fd,  Addressable __buf,  long __n,  int __flags,  Addressable __addr,  int __addr_len) {
        var mh$ = sendto$MH();
        try {
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle recvfrom$MH() {
        return RuntimeHelper.requireNonNull(constants$1.recvfrom$MH,"recvfrom");
    }
    public static long recvfrom ( int __fd,  Addressable __buf,  long __n,  int __flags,  Addressable __addr,  Addressable __addr_len) {
        var mh$ = recvfrom$MH();
        try {
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sendmsg$MH() {
        return RuntimeHelper.requireNonNull(constants$1.sendmsg$MH,"sendmsg");
    }
    public static long sendmsg ( int __fd,  Addressable __message,  int __flags) {
        var mh$ = sendmsg$MH();
        try {
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle recvmsg$MH() {
        return RuntimeHelper.requireNonNull(constants$2.recvmsg$MH,"recvmsg");
    }
    public static long recvmsg ( int __fd,  Addressable __message,  int __flags) {
        var mh$ = recvmsg$MH();
        try {
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getsockopt$MH() {
        return RuntimeHelper.requireNonNull(constants$2.getsockopt$MH,"getsockopt");
    }
    public static int getsockopt ( int __fd,  int __level,  int __optname,  Addressable __optval,  Addressable __optlen) {
        var mh$ = getsockopt$MH();
        try {
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle setsockopt$MH() {
        return RuntimeHelper.requireNonNull(constants$2.setsockopt$MH,"setsockopt");
    }
    public static int setsockopt ( int __fd,  int __level,  int __optname,  Addressable __optval,  int __optlen) {
        var mh$ = setsockopt$MH();
        try {
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle listen$MH() {
        return RuntimeHelper.requireNonNull(constants$2.listen$MH,"listen");
    }
    public static int listen ( int __fd,  int __n) {
        var mh$ = listen$MH();
        try {
            return (int)mh$.invokeExact(__fd, __n);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle accept$MH() {
        return RuntimeHelper.requireNonNull(constants$2.accept$MH,"accept");
    }
    public static int accept ( int __fd,  Addressable __addr,  Addressable __addr_len) {
        var mh$ = accept$MH();
        try {
            return (int)mh$.invokeExact(__fd, __addr, __addr_len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle shutdown$MH() {
        return RuntimeHelper.requireNonNull(constants$2.shutdown$MH,"shutdown");
    }
    public static int shutdown ( int __fd,  int __how) {
        var mh$ = shutdown$MH();
        try {
            return (int)mh$.invokeExact(__fd, __how);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle readv$MH() {
        return RuntimeHelper.requireNonNull(constants$3.readv$MH,"readv");
    }
    public static long readv ( int __fd,  Addressable __iovec,  int __count) {
        var mh$ = readv$MH();
        try {
            return (long)mh$.invokeExact(__fd, __iovec, __count);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle writev$MH() {
        return RuntimeHelper.requireNonNull(constants$3.writev$MH,"writev");
    }
    public static long writev ( int __fd,  Addressable __iovec,  int __count) {
        var mh$ = writev$MH();
        try {
            return (long)mh$.invokeExact(__fd, __iovec, __count);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle stat$MH() {
        return RuntimeHelper.requireNonNull(constants$3.stat$MH,"stat");
    }
    public static int stat ( Addressable __file,  Addressable __buf) {
        var mh$ = stat$MH();
        try {
            return (int)mh$.invokeExact(__file, __buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle fstat$MH() {
        return RuntimeHelper.requireNonNull(constants$3.fstat$MH,"fstat");
    }
    public static int fstat ( int __fd,  Addressable __buf) {
        var mh$ = fstat$MH();
        try {
            return (int)mh$.invokeExact(__fd, __buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle lstat$MH() {
        return RuntimeHelper.requireNonNull(constants$3.lstat$MH,"lstat");
    }
    public static int lstat ( Addressable __file,  Addressable __buf) {
        var mh$ = lstat$MH();
        try {
            return (int)mh$.invokeExact(__file, __buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle chmod$MH() {
        return RuntimeHelper.requireNonNull(constants$3.chmod$MH,"chmod");
    }
    public static int chmod ( Addressable __file,  int __mode) {
        var mh$ = chmod$MH();
        try {
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle fchmod$MH() {
        return RuntimeHelper.requireNonNull(constants$4.fchmod$MH,"fchmod");
    }
    public static int fchmod ( int __fd,  int __mode) {
        var mh$ = fchmod$MH();
        try {
            return (int)mh$.invokeExact(__fd, __mode);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle umask$MH() {
        return RuntimeHelper.requireNonNull(constants$4.umask$MH,"umask");
    }
    public static int umask ( int __mask) {
        var mh$ = umask$MH();
        try {
            return (int)mh$.invokeExact(__mask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle mkdir$MH() {
        return RuntimeHelper.requireNonNull(constants$4.mkdir$MH,"mkdir");
    }
    public static int mkdir ( Addressable __path,  int __mode) {
        var mh$ = mkdir$MH();
        try {
            return (int)mh$.invokeExact(__path, __mode);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle mknod$MH() {
        return RuntimeHelper.requireNonNull(constants$4.mknod$MH,"mknod");
    }
    public static int mknod ( Addressable __path,  int __mode,  long __dev) {
        var mh$ = mknod$MH();
        try {
            return (int)mh$.invokeExact(__path, __mode, __dev);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle mkfifo$MH() {
        return RuntimeHelper.requireNonNull(constants$4.mkfifo$MH,"mkfifo");
    }
    public static int mkfifo ( Addressable __path,  int __mode) {
        var mh$ = mkfifo$MH();
        try {
            return (int)mh$.invokeExact(__path, __mode);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fxstat$MH() {
        return RuntimeHelper.requireNonNull(constants$4.__fxstat$MH,"__fxstat");
    }
    public static int __fxstat ( int __ver,  int __fildes,  Addressable __stat_buf) {
        var mh$ = __fxstat$MH();
        try {
            return (int)mh$.invokeExact(__ver, __fildes, __stat_buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __xstat$MH() {
        return RuntimeHelper.requireNonNull(constants$5.__xstat$MH,"__xstat");
    }
    public static int __xstat ( int __ver,  Addressable __filename,  Addressable __stat_buf) {
        var mh$ = __xstat$MH();
        try {
            return (int)mh$.invokeExact(__ver, __filename, __stat_buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __lxstat$MH() {
        return RuntimeHelper.requireNonNull(constants$5.__lxstat$MH,"__lxstat");
    }
    public static int __lxstat ( int __ver,  Addressable __filename,  Addressable __stat_buf) {
        var mh$ = __lxstat$MH();
        try {
            return (int)mh$.invokeExact(__ver, __filename, __stat_buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fxstatat$MH() {
        return RuntimeHelper.requireNonNull(constants$5.__fxstatat$MH,"__fxstatat");
    }
    public static int __fxstatat ( int __ver,  int __fildes,  Addressable __filename,  Addressable __stat_buf,  int __flag) {
        var mh$ = __fxstatat$MH();
        try {
            return (int)mh$.invokeExact(__ver, __fildes, __filename, __stat_buf, __flag);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __xmknod$MH() {
        return RuntimeHelper.requireNonNull(constants$5.__xmknod$MH,"__xmknod");
    }
    public static int __xmknod ( int __ver,  Addressable __path,  int __mode,  Addressable __dev) {
        var mh$ = __xmknod$MH();
        try {
            return (int)mh$.invokeExact(__ver, __path, __mode, __dev);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __xmknodat$MH() {
        return RuntimeHelper.requireNonNull(constants$5.__xmknodat$MH,"__xmknodat");
    }
    public static int __xmknodat ( int __ver,  int __fd,  Addressable __path,  int __mode,  Addressable __dev) {
        var mh$ = __xmknodat$MH();
        try {
            return (int)mh$.invokeExact(__ver, __fd, __path, __mode, __dev);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __errno_location$MH() {
        return RuntimeHelper.requireNonNull(constants$5.__errno_location$MH,"__errno_location");
    }
    public static MemoryAddress __errno_location () {
        var mh$ = __errno_location$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfInt sig_atomic_t = Constants$root.C_INT$LAYOUT;
    public static int SI_ASYNCNL() {
        return (int)-60L;
    }
    public static int SI_DETHREAD() {
        return (int)-7L;
    }
    public static int SI_TKILL() {
        return (int)-6L;
    }
    public static int SI_SIGIO() {
        return (int)-5L;
    }
    public static int SI_ASYNCIO() {
        return (int)-4L;
    }
    public static int SI_MESGQ() {
        return (int)-3L;
    }
    public static int SI_TIMER() {
        return (int)-2L;
    }
    public static int SI_QUEUE() {
        return (int)-1L;
    }
    public static int SI_USER() {
        return (int)0L;
    }
    public static int SI_KERNEL() {
        return (int)128L;
    }
    public static int ILL_ILLOPC() {
        return (int)1L;
    }
    public static int ILL_ILLOPN() {
        return (int)2L;
    }
    public static int ILL_ILLADR() {
        return (int)3L;
    }
    public static int ILL_ILLTRP() {
        return (int)4L;
    }
    public static int ILL_PRVOPC() {
        return (int)5L;
    }
    public static int ILL_PRVREG() {
        return (int)6L;
    }
    public static int ILL_COPROC() {
        return (int)7L;
    }
    public static int ILL_BADSTK() {
        return (int)8L;
    }
    public static int ILL_BADIADDR() {
        return (int)9L;
    }
    public static int FPE_INTDIV() {
        return (int)1L;
    }
    public static int FPE_INTOVF() {
        return (int)2L;
    }
    public static int FPE_FLTDIV() {
        return (int)3L;
    }
    public static int FPE_FLTOVF() {
        return (int)4L;
    }
    public static int FPE_FLTUND() {
        return (int)5L;
    }
    public static int FPE_FLTRES() {
        return (int)6L;
    }
    public static int FPE_FLTINV() {
        return (int)7L;
    }
    public static int FPE_FLTSUB() {
        return (int)8L;
    }
    public static int FPE_FLTUNK() {
        return (int)14L;
    }
    public static int FPE_CONDTRAP() {
        return (int)15L;
    }
    public static int SEGV_MAPERR() {
        return (int)1L;
    }
    public static int SEGV_ACCERR() {
        return (int)2L;
    }
    public static int SEGV_BNDERR() {
        return (int)3L;
    }
    public static int SEGV_PKUERR() {
        return (int)4L;
    }
    public static int SEGV_ACCADI() {
        return (int)5L;
    }
    public static int SEGV_ADIDERR() {
        return (int)6L;
    }
    public static int SEGV_ADIPERR() {
        return (int)7L;
    }
    public static int BUS_ADRALN() {
        return (int)1L;
    }
    public static int BUS_ADRERR() {
        return (int)2L;
    }
    public static int BUS_OBJERR() {
        return (int)3L;
    }
    public static int BUS_MCEERR_AR() {
        return (int)4L;
    }
    public static int BUS_MCEERR_AO() {
        return (int)5L;
    }
    public static int TRAP_BRKPT() {
        return (int)1L;
    }
    public static int TRAP_TRACE() {
        return (int)2L;
    }
    public static int TRAP_BRANCH() {
        return (int)3L;
    }
    public static int TRAP_HWBKPT() {
        return (int)4L;
    }
    public static int TRAP_UNK() {
        return (int)5L;
    }
    public static int CLD_EXITED() {
        return (int)1L;
    }
    public static int CLD_KILLED() {
        return (int)2L;
    }
    public static int CLD_DUMPED() {
        return (int)3L;
    }
    public static int CLD_TRAPPED() {
        return (int)4L;
    }
    public static int CLD_STOPPED() {
        return (int)5L;
    }
    public static int CLD_CONTINUED() {
        return (int)6L;
    }
    public static int POLL_IN() {
        return (int)1L;
    }
    public static int POLL_OUT() {
        return (int)2L;
    }
    public static int POLL_MSG() {
        return (int)3L;
    }
    public static int POLL_ERR() {
        return (int)4L;
    }
    public static int POLL_PRI() {
        return (int)5L;
    }
    public static int POLL_HUP() {
        return (int)6L;
    }
    public static int SIGEV_SIGNAL() {
        return (int)0L;
    }
    public static int SIGEV_NONE() {
        return (int)1L;
    }
    public static int SIGEV_THREAD() {
        return (int)2L;
    }
    public static int SIGEV_THREAD_ID() {
        return (int)4L;
    }
    public static MethodHandle __sysv_signal$MH() {
        return RuntimeHelper.requireNonNull(constants$6.__sysv_signal$MH,"__sysv_signal");
    }
    public static MemoryAddress __sysv_signal ( int __sig,  Addressable __handler) {
        var mh$ = __sysv_signal$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__sig, __handler);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle signal$MH() {
        return RuntimeHelper.requireNonNull(constants$6.signal$MH,"signal");
    }
    public static MemoryAddress signal ( int __sig,  Addressable __handler) {
        var mh$ = signal$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__sig, __handler);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle bsd_signal$MH() {
        return RuntimeHelper.requireNonNull(constants$6.bsd_signal$MH,"bsd_signal");
    }
    public static MemoryAddress bsd_signal ( int __sig,  Addressable __handler) {
        var mh$ = bsd_signal$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__sig, __handler);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle kill$MH() {
        return RuntimeHelper.requireNonNull(constants$6.kill$MH,"kill");
    }
    public static int kill ( int __pid,  int __sig) {
        var mh$ = kill$MH();
        try {
            return (int)mh$.invokeExact(__pid, __sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle killpg$MH() {
        return RuntimeHelper.requireNonNull(constants$7.killpg$MH,"killpg");
    }
    public static int killpg ( int __pgrp,  int __sig) {
        var mh$ = killpg$MH();
        try {
            return (int)mh$.invokeExact(__pgrp, __sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle raise$MH() {
        return RuntimeHelper.requireNonNull(constants$7.raise$MH,"raise");
    }
    public static int raise ( int __sig) {
        var mh$ = raise$MH();
        try {
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigpause$MH() {
        return RuntimeHelper.requireNonNull(constants$7.sigpause$MH,"sigpause");
    }
    public static int sigpause ( int __sig) {
        var mh$ = sigpause$MH();
        try {
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigemptyset$MH() {
        return RuntimeHelper.requireNonNull(constants$7.sigemptyset$MH,"sigemptyset");
    }
    public static int sigemptyset ( Addressable __set) {
        var mh$ = sigemptyset$MH();
        try {
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigfillset$MH() {
        return RuntimeHelper.requireNonNull(constants$7.sigfillset$MH,"sigfillset");
    }
    public static int sigfillset ( Addressable __set) {
        var mh$ = sigfillset$MH();
        try {
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigaddset$MH() {
        return RuntimeHelper.requireNonNull(constants$7.sigaddset$MH,"sigaddset");
    }
    public static int sigaddset ( Addressable __set,  int __signo) {
        var mh$ = sigaddset$MH();
        try {
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigdelset$MH() {
        return RuntimeHelper.requireNonNull(constants$8.sigdelset$MH,"sigdelset");
    }
    public static int sigdelset ( Addressable __set,  int __signo) {
        var mh$ = sigdelset$MH();
        try {
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigismember$MH() {
        return RuntimeHelper.requireNonNull(constants$8.sigismember$MH,"sigismember");
    }
    public static int sigismember ( Addressable __set,  int __signo) {
        var mh$ = sigismember$MH();
        try {
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigprocmask$MH() {
        return RuntimeHelper.requireNonNull(constants$8.sigprocmask$MH,"sigprocmask");
    }
    public static int sigprocmask ( int __how,  Addressable __set,  Addressable __oset) {
        var mh$ = sigprocmask$MH();
        try {
            return (int)mh$.invokeExact(__how, __set, __oset);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigsuspend$MH() {
        return RuntimeHelper.requireNonNull(constants$8.sigsuspend$MH,"sigsuspend");
    }
    public static int sigsuspend ( Addressable __set) {
        var mh$ = sigsuspend$MH();
        try {
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigaction$MH() {
        return RuntimeHelper.requireNonNull(constants$8.sigaction$MH,"sigaction");
    }
    public static int sigaction ( int __sig,  Addressable __act,  Addressable __oact) {
        var mh$ = sigaction$MH();
        try {
            return (int)mh$.invokeExact(__sig, __act, __oact);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigpending$MH() {
        return RuntimeHelper.requireNonNull(constants$8.sigpending$MH,"sigpending");
    }
    public static int sigpending ( Addressable __set) {
        var mh$ = sigpending$MH();
        try {
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigwait$MH() {
        return RuntimeHelper.requireNonNull(constants$9.sigwait$MH,"sigwait");
    }
    public static int sigwait ( Addressable __set,  Addressable __sig) {
        var mh$ = sigwait$MH();
        try {
            return (int)mh$.invokeExact(__set, __sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigwaitinfo$MH() {
        return RuntimeHelper.requireNonNull(constants$9.sigwaitinfo$MH,"sigwaitinfo");
    }
    public static int sigwaitinfo ( Addressable __set,  Addressable __info) {
        var mh$ = sigwaitinfo$MH();
        try {
            return (int)mh$.invokeExact(__set, __info);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigtimedwait$MH() {
        return RuntimeHelper.requireNonNull(constants$9.sigtimedwait$MH,"sigtimedwait");
    }
    public static int sigtimedwait ( Addressable __set,  Addressable __info,  Addressable __timeout) {
        var mh$ = sigtimedwait$MH();
        try {
            return (int)mh$.invokeExact(__set, __info, __timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigqueue$MH() {
        return RuntimeHelper.requireNonNull(constants$9.sigqueue$MH,"sigqueue");
    }
    public static int sigqueue ( int __pid,  int __sig,  MemorySegment __val) {
        var mh$ = sigqueue$MH();
        try {
            return (int)mh$.invokeExact(__pid, __sig, __val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfLong greg_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfAddress fpregset_t = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle siginterrupt$MH() {
        return RuntimeHelper.requireNonNull(constants$9.siginterrupt$MH,"siginterrupt");
    }
    public static int siginterrupt ( int __sig,  int __interrupt) {
        var mh$ = siginterrupt$MH();
        try {
            return (int)mh$.invokeExact(__sig, __interrupt);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int SS_ONSTACK() {
        return (int)1L;
    }
    public static int SS_DISABLE() {
        return (int)2L;
    }
    public static MethodHandle sigaltstack$MH() {
        return RuntimeHelper.requireNonNull(constants$9.sigaltstack$MH,"sigaltstack");
    }
    public static int sigaltstack ( Addressable __ss,  Addressable __oss) {
        var mh$ = sigaltstack$MH();
        try {
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigstack$MH() {
        return RuntimeHelper.requireNonNull(constants$10.sigstack$MH,"sigstack");
    }
    public static int sigstack ( Addressable __ss,  Addressable __oss) {
        var mh$ = sigstack$MH();
        try {
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sighold$MH() {
        return RuntimeHelper.requireNonNull(constants$10.sighold$MH,"sighold");
    }
    public static int sighold ( int __sig) {
        var mh$ = sighold$MH();
        try {
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigrelse$MH() {
        return RuntimeHelper.requireNonNull(constants$10.sigrelse$MH,"sigrelse");
    }
    public static int sigrelse ( int __sig) {
        var mh$ = sigrelse$MH();
        try {
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigignore$MH() {
        return RuntimeHelper.requireNonNull(constants$10.sigignore$MH,"sigignore");
    }
    public static int sigignore ( int __sig) {
        var mh$ = sigignore$MH();
        try {
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sigset$MH() {
        return RuntimeHelper.requireNonNull(constants$10.sigset$MH,"sigset");
    }
    public static MemoryAddress sigset ( int __sig,  Addressable __disp) {
        var mh$ = sigset$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__sig, __disp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle pthread_sigmask$MH() {
        return RuntimeHelper.requireNonNull(constants$10.pthread_sigmask$MH,"pthread_sigmask");
    }
    public static int pthread_sigmask ( int __how,  Addressable __newmask,  Addressable __oldmask) {
        var mh$ = pthread_sigmask$MH();
        try {
            return (int)mh$.invokeExact(__how, __newmask, __oldmask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle pthread_kill$MH() {
        return RuntimeHelper.requireNonNull(constants$11.pthread_kill$MH,"pthread_kill");
    }
    public static int pthread_kill ( long __threadid,  int __signo) {
        var mh$ = pthread_kill$MH();
        try {
            return (int)mh$.invokeExact(__threadid, __signo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __libc_current_sigrtmin$MH() {
        return RuntimeHelper.requireNonNull(constants$11.__libc_current_sigrtmin$MH,"__libc_current_sigrtmin");
    }
    public static int __libc_current_sigrtmin () {
        var mh$ = __libc_current_sigrtmin$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __libc_current_sigrtmax$MH() {
        return RuntimeHelper.requireNonNull(constants$11.__libc_current_sigrtmax$MH,"__libc_current_sigrtmax");
    }
    public static int __libc_current_sigrtmax () {
        var mh$ = __libc_current_sigrtmax$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfShort int_least16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfInt int_least32_t = Constants$root.C_INT$LAYOUT;
    public static OfLong int_least64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong int_fast16_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong int_fast32_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong int_fast64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong intptr_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong intmax_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __gwchar_t = Constants$root.C_INT$LAYOUT;
    public static MethodHandle imaxabs$MH() {
        return RuntimeHelper.requireNonNull(constants$11.imaxabs$MH,"imaxabs");
    }
    public static long imaxabs ( long __n) {
        var mh$ = imaxabs$MH();
        try {
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle imaxdiv$MH() {
        return RuntimeHelper.requireNonNull(constants$11.imaxdiv$MH,"imaxdiv");
    }
    public static MemorySegment imaxdiv ( SegmentAllocator allocator,  long __numer,  long __denom) {
        var mh$ = imaxdiv$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle strtoimax$MH() {
        return RuntimeHelper.requireNonNull(constants$11.strtoimax$MH,"strtoimax");
    }
    public static long strtoimax ( Addressable __nptr,  Addressable __endptr,  int __base) {
        var mh$ = strtoimax$MH();
        try {
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle strtoumax$MH() {
        return RuntimeHelper.requireNonNull(constants$12.strtoumax$MH,"strtoumax");
    }
    public static long strtoumax ( Addressable __nptr,  Addressable __endptr,  int __base) {
        var mh$ = strtoumax$MH();
        try {
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle wcstoimax$MH() {
        return RuntimeHelper.requireNonNull(constants$12.wcstoimax$MH,"wcstoimax");
    }
    public static long wcstoimax ( Addressable __nptr,  Addressable __endptr,  int __base) {
        var mh$ = wcstoimax$MH();
        try {
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle wcstoumax$MH() {
        return RuntimeHelper.requireNonNull(constants$12.wcstoumax$MH,"wcstoumax");
    }
    public static long wcstoumax ( Addressable __nptr,  Addressable __endptr,  int __base) {
        var mh$ = wcstoumax$MH();
        try {
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __sysconf$MH() {
        return RuntimeHelper.requireNonNull(constants$12.__sysconf$MH,"__sysconf");
    }
    public static long __sysconf ( int x0) {
        var mh$ = __sysconf$MH();
        try {
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle clock$MH() {
        return RuntimeHelper.requireNonNull(constants$12.clock$MH,"clock");
    }
    public static long clock () {
        var mh$ = clock$MH();
        try {
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle time$MH() {
        return RuntimeHelper.requireNonNull(constants$12.time$MH,"time");
    }
    public static long time ( Addressable __timer) {
        var mh$ = time$MH();
        try {
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle difftime$MH() {
        return RuntimeHelper.requireNonNull(constants$13.difftime$MH,"difftime");
    }
    public static double difftime ( long __time1,  long __time0) {
        var mh$ = difftime$MH();
        try {
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle mktime$MH() {
        return RuntimeHelper.requireNonNull(constants$13.mktime$MH,"mktime");
    }
    public static long mktime ( Addressable __tp) {
        var mh$ = mktime$MH();
        try {
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle strftime$MH() {
        return RuntimeHelper.requireNonNull(constants$13.strftime$MH,"strftime");
    }
    public static long strftime ( Addressable __s,  long __maxsize,  Addressable __format,  Addressable __tp) {
        var mh$ = strftime$MH();
        try {
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle strptime$MH() {
        return RuntimeHelper.requireNonNull(constants$13.strptime$MH,"strptime");
    }
    public static MemoryAddress strptime ( Addressable __s,  Addressable __fmt,  Addressable __tp) {
        var mh$ = strptime$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__s, __fmt, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle gmtime$MH() {
        return RuntimeHelper.requireNonNull(constants$13.gmtime$MH,"gmtime");
    }
    public static MemoryAddress gmtime ( Addressable __timer) {
        var mh$ = gmtime$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle localtime$MH() {
        return RuntimeHelper.requireNonNull(constants$13.localtime$MH,"localtime");
    }
    public static MemoryAddress localtime ( Addressable __timer) {
        var mh$ = localtime$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle gmtime_r$MH() {
        return RuntimeHelper.requireNonNull(constants$14.gmtime_r$MH,"gmtime_r");
    }
    public static MemoryAddress gmtime_r ( Addressable __timer,  Addressable __tp) {
        var mh$ = gmtime_r$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle localtime_r$MH() {
        return RuntimeHelper.requireNonNull(constants$14.localtime_r$MH,"localtime_r");
    }
    public static MemoryAddress localtime_r ( Addressable __timer,  Addressable __tp) {
        var mh$ = localtime_r$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle asctime$MH() {
        return RuntimeHelper.requireNonNull(constants$14.asctime$MH,"asctime");
    }
    public static MemoryAddress asctime ( Addressable __tp) {
        var mh$ = asctime$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ctime$MH() {
        return RuntimeHelper.requireNonNull(constants$14.ctime$MH,"ctime");
    }
    public static MemoryAddress ctime ( Addressable __timer) {
        var mh$ = ctime$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle asctime_r$MH() {
        return RuntimeHelper.requireNonNull(constants$14.asctime_r$MH,"asctime_r");
    }
    public static MemoryAddress asctime_r ( Addressable __tp,  Addressable __buf) {
        var mh$ = asctime_r$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ctime_r$MH() {
        return RuntimeHelper.requireNonNull(constants$14.ctime_r$MH,"ctime_r");
    }
    public static MemoryAddress ctime_r ( Addressable __timer,  Addressable __buf) {
        var mh$ = ctime_r$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MemorySegment __tzname$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$15.__tzname$SEGMENT,"__tzname");
    }
    public static MemoryLayout __daylight$LAYOUT() {
        return constants$15.__daylight$LAYOUT;
    }
    public static VarHandle __daylight$VH() {
        return constants$15.__daylight$VH;
    }
    public static MemorySegment __daylight$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$15.__daylight$SEGMENT,"__daylight");
    }
    public static int __daylight$get() {
        return (int) constants$15.__daylight$VH.get(RuntimeHelper.requireNonNull(constants$15.__daylight$SEGMENT, "__daylight"));
    }
    public static void __daylight$set( int x) {
        constants$15.__daylight$VH.set(RuntimeHelper.requireNonNull(constants$15.__daylight$SEGMENT, "__daylight"), x);
    }
    public static MemoryLayout __timezone$LAYOUT() {
        return constants$15.__timezone$LAYOUT;
    }
    public static VarHandle __timezone$VH() {
        return constants$15.__timezone$VH;
    }
    public static MemorySegment __timezone$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$15.__timezone$SEGMENT,"__timezone");
    }
    public static long __timezone$get() {
        return (long) constants$15.__timezone$VH.get(RuntimeHelper.requireNonNull(constants$15.__timezone$SEGMENT, "__timezone"));
    }
    public static void __timezone$set( long x) {
        constants$15.__timezone$VH.set(RuntimeHelper.requireNonNull(constants$15.__timezone$SEGMENT, "__timezone"), x);
    }
    public static MemorySegment tzname$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$15.tzname$SEGMENT,"tzname");
    }
    public static MethodHandle tzset$MH() {
        return RuntimeHelper.requireNonNull(constants$15.tzset$MH,"tzset");
    }
    public static void tzset () {
        var mh$ = tzset$MH();
        try {
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MemoryLayout daylight$LAYOUT() {
        return constants$15.daylight$LAYOUT;
    }
    public static VarHandle daylight$VH() {
        return constants$15.daylight$VH;
    }
    public static MemorySegment daylight$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$15.daylight$SEGMENT,"daylight");
    }
    public static int daylight$get() {
        return (int) constants$15.daylight$VH.get(RuntimeHelper.requireNonNull(constants$15.daylight$SEGMENT, "daylight"));
    }
    public static void daylight$set( int x) {
        constants$15.daylight$VH.set(RuntimeHelper.requireNonNull(constants$15.daylight$SEGMENT, "daylight"), x);
    }
    public static MemoryLayout timezone$LAYOUT() {
        return constants$16.timezone$LAYOUT;
    }
    public static VarHandle timezone$VH() {
        return constants$16.timezone$VH;
    }
    public static MemorySegment timezone$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$16.timezone$SEGMENT,"timezone");
    }
    public static long timezone$get() {
        return (long) constants$16.timezone$VH.get(RuntimeHelper.requireNonNull(constants$16.timezone$SEGMENT, "timezone"));
    }
    public static void timezone$set( long x) {
        constants$16.timezone$VH.set(RuntimeHelper.requireNonNull(constants$16.timezone$SEGMENT, "timezone"), x);
    }
    public static MethodHandle nanosleep$MH() {
        return RuntimeHelper.requireNonNull(constants$16.nanosleep$MH,"nanosleep");
    }
    public static int nanosleep ( Addressable __requested_time,  Addressable __remaining) {
        var mh$ = nanosleep$MH();
        try {
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle clock_getres$MH() {
        return RuntimeHelper.requireNonNull(constants$16.clock_getres$MH,"clock_getres");
    }
    public static int clock_getres ( int __clock_id,  Addressable __res) {
        var mh$ = clock_getres$MH();
        try {
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle clock_gettime$MH() {
        return RuntimeHelper.requireNonNull(constants$16.clock_gettime$MH,"clock_gettime");
    }
    public static int clock_gettime ( int __clock_id,  Addressable __tp) {
        var mh$ = clock_gettime$MH();
        try {
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle clock_settime$MH() {
        return RuntimeHelper.requireNonNull(constants$16.clock_settime$MH,"clock_settime");
    }
    public static int clock_settime ( int __clock_id,  Addressable __tp) {
        var mh$ = clock_settime$MH();
        try {
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle timer_create$MH() {
        return RuntimeHelper.requireNonNull(constants$16.timer_create$MH,"timer_create");
    }
    public static int timer_create ( int __clock_id,  Addressable __evp,  Addressable __timerid) {
        var mh$ = timer_create$MH();
        try {
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle timer_delete$MH() {
        return RuntimeHelper.requireNonNull(constants$17.timer_delete$MH,"timer_delete");
    }
    public static int timer_delete ( Addressable __timerid) {
        var mh$ = timer_delete$MH();
        try {
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle timer_settime$MH() {
        return RuntimeHelper.requireNonNull(constants$17.timer_settime$MH,"timer_settime");
    }
    public static int timer_settime ( Addressable __timerid,  int __flags,  Addressable __value,  Addressable __ovalue) {
        var mh$ = timer_settime$MH();
        try {
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle timer_gettime$MH() {
        return RuntimeHelper.requireNonNull(constants$17.timer_gettime$MH,"timer_gettime");
    }
    public static int timer_gettime ( Addressable __timerid,  Addressable __value) {
        var mh$ = timer_gettime$MH();
        try {
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle timer_getoverrun$MH() {
        return RuntimeHelper.requireNonNull(constants$17.timer_getoverrun$MH,"timer_getoverrun");
    }
    public static int timer_getoverrun ( Addressable __timerid) {
        var mh$ = timer_getoverrun$MH();
        try {
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle timespec_get$MH() {
        return RuntimeHelper.requireNonNull(constants$17.timespec_get$MH,"timespec_get");
    }
    public static int timespec_get ( Addressable __ts,  int __base) {
        var mh$ = timespec_get$MH();
        try {
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MemoryLayout getdate_err$LAYOUT() {
        return constants$17.getdate_err$LAYOUT;
    }
    public static VarHandle getdate_err$VH() {
        return constants$17.getdate_err$VH;
    }
    public static MemorySegment getdate_err$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$17.getdate_err$SEGMENT,"getdate_err");
    }
    public static int getdate_err$get() {
        return (int) constants$17.getdate_err$VH.get(RuntimeHelper.requireNonNull(constants$17.getdate_err$SEGMENT, "getdate_err"));
    }
    public static void getdate_err$set( int x) {
        constants$17.getdate_err$VH.set(RuntimeHelper.requireNonNull(constants$17.getdate_err$SEGMENT, "getdate_err"), x);
    }
    public static MethodHandle getdate$MH() {
        return RuntimeHelper.requireNonNull(constants$18.getdate$MH,"getdate");
    }
    public static MemoryAddress getdate ( Addressable __string) {
        var mh$ = getdate$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfShort __s16 = Constants$root.C_SHORT$LAYOUT;
    public static OfInt __s32 = Constants$root.C_INT$LAYOUT;
    public static OfLong __s64 = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __kernel_key_t = Constants$root.C_INT$LAYOUT;
    public static OfInt __kernel_mqd_t = Constants$root.C_INT$LAYOUT;
    public static OfLong __kernel_long_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __kernel_pid_t = Constants$root.C_INT$LAYOUT;
    public static OfInt __kernel_ipc_pid_t = Constants$root.C_INT$LAYOUT;
    public static OfLong __kernel_suseconds_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __kernel_daddr_t = Constants$root.C_INT$LAYOUT;
    public static OfLong __kernel_ssize_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __kernel_ptrdiff_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __kernel_off_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __kernel_loff_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __kernel_time_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __kernel_time64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong __kernel_clock_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt __kernel_timer_t = Constants$root.C_INT$LAYOUT;
    public static OfInt __kernel_clockid_t = Constants$root.C_INT$LAYOUT;
    public static OfAddress __kernel_caddr_t = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle __arch_swab32$MH() {
        return RuntimeHelper.requireNonNull(constants$18.__arch_swab32$MH,"__arch_swab32");
    }
    public static int __arch_swab32 ( int val) {
        var mh$ = __arch_swab32$MH();
        try {
            return (int)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __arch_swab64$MH() {
        return RuntimeHelper.requireNonNull(constants$18.__arch_swab64$MH,"__arch_swab64");
    }
    public static long __arch_swab64 ( long val) {
        var mh$ = __arch_swab64$MH();
        try {
            return (long)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fswab16$MH() {
        return RuntimeHelper.requireNonNull(constants$18.__fswab16$MH,"__fswab16");
    }
    public static short __fswab16 ( short val) {
        var mh$ = __fswab16$MH();
        try {
            return (short)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fswab32$MH() {
        return RuntimeHelper.requireNonNull(constants$19.__fswab32$MH,"__fswab32");
    }
    public static int __fswab32 ( int val) {
        var mh$ = __fswab32$MH();
        try {
            return (int)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fswab64$MH() {
        return RuntimeHelper.requireNonNull(constants$19.__fswab64$MH,"__fswab64");
    }
    public static long __fswab64 ( long val) {
        var mh$ = __fswab64$MH();
        try {
            return (long)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fswahw32$MH() {
        return RuntimeHelper.requireNonNull(constants$19.__fswahw32$MH,"__fswahw32");
    }
    public static int __fswahw32 ( int val) {
        var mh$ = __fswahw32$MH();
        try {
            return (int)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __fswahb32$MH() {
        return RuntimeHelper.requireNonNull(constants$19.__fswahb32$MH,"__fswahb32");
    }
    public static int __fswahb32 ( int val) {
        var mh$ = __fswahb32$MH();
        try {
            return (int)mh$.invokeExact(val);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab$MH() {
        return RuntimeHelper.requireNonNull(constants$19.__swab$MH,"__swab");
    }
    public static long __swab ( long y) {
        var mh$ = __swab$MH();
        try {
            return (long)mh$.invokeExact(y);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab16p$MH() {
        return RuntimeHelper.requireNonNull(constants$19.__swab16p$MH,"__swab16p");
    }
    public static short __swab16p ( Addressable p) {
        var mh$ = __swab16p$MH();
        try {
            return (short)mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab32p$MH() {
        return RuntimeHelper.requireNonNull(constants$20.__swab32p$MH,"__swab32p");
    }
    public static int __swab32p ( Addressable p) {
        var mh$ = __swab32p$MH();
        try {
            return (int)mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab64p$MH() {
        return RuntimeHelper.requireNonNull(constants$20.__swab64p$MH,"__swab64p");
    }
    public static long __swab64p ( Addressable p) {
        var mh$ = __swab64p$MH();
        try {
            return (long)mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swahw32p$MH() {
        return RuntimeHelper.requireNonNull(constants$20.__swahw32p$MH,"__swahw32p");
    }
    public static int __swahw32p ( Addressable p) {
        var mh$ = __swahw32p$MH();
        try {
            return (int)mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swahb32p$MH() {
        return RuntimeHelper.requireNonNull(constants$20.__swahb32p$MH,"__swahb32p");
    }
    public static int __swahb32p ( Addressable p) {
        var mh$ = __swahb32p$MH();
        try {
            return (int)mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab16s$MH() {
        return RuntimeHelper.requireNonNull(constants$20.__swab16s$MH,"__swab16s");
    }
    public static void __swab16s ( Addressable p) {
        var mh$ = __swab16s$MH();
        try {
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab32s$MH() {
        return RuntimeHelper.requireNonNull(constants$20.__swab32s$MH,"__swab32s");
    }
    public static void __swab32s ( Addressable p) {
        var mh$ = __swab32s$MH();
        try {
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swab64s$MH() {
        return RuntimeHelper.requireNonNull(constants$21.__swab64s$MH,"__swab64s");
    }
    public static void __swab64s ( Addressable p) {
        var mh$ = __swab64s$MH();
        try {
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swahw32s$MH() {
        return RuntimeHelper.requireNonNull(constants$21.__swahw32s$MH,"__swahw32s");
    }
    public static void __swahw32s ( Addressable p) {
        var mh$ = __swahw32s$MH();
        try {
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __swahb32s$MH() {
        return RuntimeHelper.requireNonNull(constants$21.__swahb32s$MH,"__swahb32s");
    }
    public static void __swahb32s ( Addressable p) {
        var mh$ = __swahb32s$MH();
        try {
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int FSCONFIG_SET_FLAG() {
        return (int)0L;
    }
    public static int FSCONFIG_SET_STRING() {
        return (int)1L;
    }
    public static int FSCONFIG_SET_BINARY() {
        return (int)2L;
    }
    public static int FSCONFIG_SET_PATH() {
        return (int)3L;
    }
    public static int FSCONFIG_SET_PATH_EMPTY() {
        return (int)4L;
    }
    public static int FSCONFIG_SET_FD() {
        return (int)5L;
    }
    public static int FSCONFIG_CMD_CREATE() {
        return (int)6L;
    }
    public static int FSCONFIG_CMD_RECONFIGURE() {
        return (int)7L;
    }
    public static OfInt __kernel_rwf_t = Constants$root.C_INT$LAYOUT;
    public static int IOSQE_FIXED_FILE_BIT() {
        return (int)0L;
    }
    public static int IOSQE_IO_DRAIN_BIT() {
        return (int)1L;
    }
    public static int IOSQE_IO_LINK_BIT() {
        return (int)2L;
    }
    public static int IOSQE_IO_HARDLINK_BIT() {
        return (int)3L;
    }
    public static int IOSQE_ASYNC_BIT() {
        return (int)4L;
    }
    public static int IOSQE_BUFFER_SELECT_BIT() {
        return (int)5L;
    }
    public static int IORING_OP_NOP() {
        return (int)0L;
    }
    public static int IORING_OP_READV() {
        return (int)1L;
    }
    public static int IORING_OP_WRITEV() {
        return (int)2L;
    }
    public static int IORING_OP_FSYNC() {
        return (int)3L;
    }
    public static int IORING_OP_READ_FIXED() {
        return (int)4L;
    }
    public static int IORING_OP_WRITE_FIXED() {
        return (int)5L;
    }
    public static int IORING_OP_POLL_ADD() {
        return (int)6L;
    }
    public static int IORING_OP_POLL_REMOVE() {
        return (int)7L;
    }
    public static int IORING_OP_SYNC_FILE_RANGE() {
        return (int)8L;
    }
    public static int IORING_OP_SENDMSG() {
        return (int)9L;
    }
    public static int IORING_OP_RECVMSG() {
        return (int)10L;
    }
    public static int IORING_OP_TIMEOUT() {
        return (int)11L;
    }
    public static int IORING_OP_TIMEOUT_REMOVE() {
        return (int)12L;
    }
    public static int IORING_OP_ACCEPT() {
        return (int)13L;
    }
    public static int IORING_OP_ASYNC_CANCEL() {
        return (int)14L;
    }
    public static int IORING_OP_LINK_TIMEOUT() {
        return (int)15L;
    }
    public static int IORING_OP_CONNECT() {
        return (int)16L;
    }
    public static int IORING_OP_FALLOCATE() {
        return (int)17L;
    }
    public static int IORING_OP_OPENAT() {
        return (int)18L;
    }
    public static int IORING_OP_CLOSE() {
        return (int)19L;
    }
    public static int IORING_OP_FILES_UPDATE() {
        return (int)20L;
    }
    public static int IORING_OP_STATX() {
        return (int)21L;
    }
    public static int IORING_OP_READ() {
        return (int)22L;
    }
    public static int IORING_OP_WRITE() {
        return (int)23L;
    }
    public static int IORING_OP_FADVISE() {
        return (int)24L;
    }
    public static int IORING_OP_MADVISE() {
        return (int)25L;
    }
    public static int IORING_OP_SEND() {
        return (int)26L;
    }
    public static int IORING_OP_RECV() {
        return (int)27L;
    }
    public static int IORING_OP_OPENAT2() {
        return (int)28L;
    }
    public static int IORING_OP_EPOLL_CTL() {
        return (int)29L;
    }
    public static int IORING_OP_SPLICE() {
        return (int)30L;
    }
    public static int IORING_OP_PROVIDE_BUFFERS() {
        return (int)31L;
    }
    public static int IORING_OP_REMOVE_BUFFERS() {
        return (int)32L;
    }
    public static int IORING_OP_TEE() {
        return (int)33L;
    }
    public static int IORING_OP_SHUTDOWN() {
        return (int)34L;
    }
    public static int IORING_OP_RENAMEAT() {
        return (int)35L;
    }
    public static int IORING_OP_UNLINKAT() {
        return (int)36L;
    }
    public static int IORING_OP_MKDIRAT() {
        return (int)37L;
    }
    public static int IORING_OP_LAST() {
        return (int)38L;
    }
    public static int IORING_CQE_BUFFER_SHIFT() {
        return (int)16L;
    }
    public static int IORING_REGISTER_BUFFERS() {
        return (int)0L;
    }
    public static int IORING_UNREGISTER_BUFFERS() {
        return (int)1L;
    }
    public static int IORING_REGISTER_FILES() {
        return (int)2L;
    }
    public static int IORING_UNREGISTER_FILES() {
        return (int)3L;
    }
    public static int IORING_REGISTER_EVENTFD() {
        return (int)4L;
    }
    public static int IORING_UNREGISTER_EVENTFD() {
        return (int)5L;
    }
    public static int IORING_REGISTER_FILES_UPDATE() {
        return (int)6L;
    }
    public static int IORING_REGISTER_EVENTFD_ASYNC() {
        return (int)7L;
    }
    public static int IORING_REGISTER_PROBE() {
        return (int)8L;
    }
    public static int IORING_REGISTER_PERSONALITY() {
        return (int)9L;
    }
    public static int IORING_UNREGISTER_PERSONALITY() {
        return (int)10L;
    }
    public static int IORING_REGISTER_RESTRICTIONS() {
        return (int)11L;
    }
    public static int IORING_REGISTER_ENABLE_RINGS() {
        return (int)12L;
    }
    public static int IORING_REGISTER_LAST() {
        return (int)13L;
    }
    public static int IORING_RESTRICTION_REGISTER_OP() {
        return (int)0L;
    }
    public static int IORING_RESTRICTION_SQE_OP() {
        return (int)1L;
    }
    public static int IORING_RESTRICTION_SQE_FLAGS_ALLOWED() {
        return (int)2L;
    }
    public static int IORING_RESTRICTION_SQE_FLAGS_REQUIRED() {
        return (int)3L;
    }
    public static int IORING_RESTRICTION_LAST() {
        return (int)4L;
    }
    public static OfLong ptrdiff_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt wchar_t = Constants$root.C_INT$LAYOUT;
    public static int memory_order_relaxed() {
        return (int)0L;
    }
    public static int memory_order_consume() {
        return (int)1L;
    }
    public static int memory_order_acquire() {
        return (int)2L;
    }
    public static int memory_order_release() {
        return (int)3L;
    }
    public static int memory_order_acq_rel() {
        return (int)4L;
    }
    public static int memory_order_seq_cst() {
        return (int)5L;
    }
    public static MethodHandle atomic_thread_fence$MH() {
        return RuntimeHelper.requireNonNull(constants$21.atomic_thread_fence$MH,"atomic_thread_fence");
    }
    public static void atomic_thread_fence ( int x0) {
        var mh$ = atomic_thread_fence$MH();
        try {
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle atomic_signal_fence$MH() {
        return RuntimeHelper.requireNonNull(constants$21.atomic_signal_fence$MH,"atomic_signal_fence");
    }
    public static void atomic_signal_fence ( int x0) {
        var mh$ = atomic_signal_fence$MH();
        try {
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle atomic_flag_test_and_set$MH() {
        return RuntimeHelper.requireNonNull(constants$21.atomic_flag_test_and_set$MH,"atomic_flag_test_and_set");
    }
    public static boolean atomic_flag_test_and_set ( Addressable x0) {
        var mh$ = atomic_flag_test_and_set$MH();
        try {
            return (boolean)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle atomic_flag_test_and_set_explicit$MH() {
        return RuntimeHelper.requireNonNull(constants$22.atomic_flag_test_and_set_explicit$MH,"atomic_flag_test_and_set_explicit");
    }
    public static boolean atomic_flag_test_and_set_explicit ( Addressable x0,  int x1) {
        var mh$ = atomic_flag_test_and_set_explicit$MH();
        try {
            return (boolean)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle atomic_flag_clear$MH() {
        return RuntimeHelper.requireNonNull(constants$22.atomic_flag_clear$MH,"atomic_flag_clear");
    }
    public static void atomic_flag_clear ( Addressable x0) {
        var mh$ = atomic_flag_clear$MH();
        try {
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle atomic_flag_clear_explicit$MH() {
        return RuntimeHelper.requireNonNull(constants$22.atomic_flag_clear_explicit$MH,"atomic_flag_clear_explicit");
    }
    public static void atomic_flag_clear_explicit ( Addressable x0,  int x1) {
        var mh$ = atomic_flag_clear_explicit$MH();
        try {
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_get_probe_ring$MH() {
        return RuntimeHelper.requireNonNull(constants$22.io_uring_get_probe_ring$MH,"io_uring_get_probe_ring");
    }
    public static MemoryAddress io_uring_get_probe_ring ( Addressable ring) {
        var mh$ = io_uring_get_probe_ring$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_get_probe$MH() {
        return RuntimeHelper.requireNonNull(constants$22.io_uring_get_probe$MH,"io_uring_get_probe");
    }
    public static MemoryAddress io_uring_get_probe () {
        var mh$ = io_uring_get_probe$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_free_probe$MH() {
        return RuntimeHelper.requireNonNull(constants$22.io_uring_free_probe$MH,"io_uring_free_probe");
    }
    public static void io_uring_free_probe ( Addressable probe) {
        var mh$ = io_uring_free_probe$MH();
        try {
            mh$.invokeExact(probe);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_opcode_supported_ring$MH() {
        return RuntimeHelper.requireNonNull(constants$23.io_uring_opcode_supported_ring$MH,"io_uring_opcode_supported_ring");
    }
    public static int io_uring_opcode_supported_ring ( Addressable ring,  int op) {
        var mh$ = io_uring_opcode_supported_ring$MH();
        try {
            return (int)mh$.invokeExact(ring, op);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_opcode_supported$MH() {
        return RuntimeHelper.requireNonNull(constants$23.io_uring_opcode_supported$MH,"io_uring_opcode_supported");
    }
    public static int io_uring_opcode_supported ( Addressable p,  int op) {
        var mh$ = io_uring_opcode_supported$MH();
        try {
            return (int)mh$.invokeExact(p, op);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_queue_init_params$MH() {
        return RuntimeHelper.requireNonNull(constants$23.io_uring_queue_init_params$MH,"io_uring_queue_init_params");
    }
    public static int io_uring_queue_init_params ( int entries,  Addressable ring,  Addressable p) {
        var mh$ = io_uring_queue_init_params$MH();
        try {
            return (int)mh$.invokeExact(entries, ring, p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_queue_init$MH() {
        return RuntimeHelper.requireNonNull(constants$23.io_uring_queue_init$MH,"io_uring_queue_init");
    }
    public static int io_uring_queue_init ( int entries,  Addressable ring,  int flags) {
        var mh$ = io_uring_queue_init$MH();
        try {
            return (int)mh$.invokeExact(entries, ring, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_queue_mmap$MH() {
        return RuntimeHelper.requireNonNull(constants$23.io_uring_queue_mmap$MH,"io_uring_queue_mmap");
    }
    public static int io_uring_queue_mmap ( int fd,  Addressable p,  Addressable ring) {
        var mh$ = io_uring_queue_mmap$MH();
        try {
            return (int)mh$.invokeExact(fd, p, ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_ring_dontfork$MH() {
        return RuntimeHelper.requireNonNull(constants$23.io_uring_ring_dontfork$MH,"io_uring_ring_dontfork");
    }
    public static int io_uring_ring_dontfork ( Addressable ring) {
        var mh$ = io_uring_ring_dontfork$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_queue_exit$MH() {
        return RuntimeHelper.requireNonNull(constants$24.io_uring_queue_exit$MH,"io_uring_queue_exit");
    }
    public static void io_uring_queue_exit ( Addressable ring) {
        var mh$ = io_uring_queue_exit$MH();
        try {
            mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_peek_batch_cqe$MH() {
        return RuntimeHelper.requireNonNull(constants$24.io_uring_peek_batch_cqe$MH,"io_uring_peek_batch_cqe");
    }
    public static int io_uring_peek_batch_cqe ( Addressable ring,  Addressable cqes,  int count) {
        var mh$ = io_uring_peek_batch_cqe$MH();
        try {
            return (int)mh$.invokeExact(ring, cqes, count);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_wait_cqes$MH() {
        return RuntimeHelper.requireNonNull(constants$24.io_uring_wait_cqes$MH,"io_uring_wait_cqes");
    }
    public static int io_uring_wait_cqes ( Addressable ring,  Addressable cqe_ptr,  int wait_nr,  Addressable ts,  Addressable sigmask) {
        var mh$ = io_uring_wait_cqes$MH();
        try {
            return (int)mh$.invokeExact(ring, cqe_ptr, wait_nr, ts, sigmask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_wait_cqe_timeout$MH() {
        return RuntimeHelper.requireNonNull(constants$24.io_uring_wait_cqe_timeout$MH,"io_uring_wait_cqe_timeout");
    }
    public static int io_uring_wait_cqe_timeout ( Addressable ring,  Addressable cqe_ptr,  Addressable ts) {
        var mh$ = io_uring_wait_cqe_timeout$MH();
        try {
            return (int)mh$.invokeExact(ring, cqe_ptr, ts);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_submit$MH() {
        return RuntimeHelper.requireNonNull(constants$24.io_uring_submit$MH,"io_uring_submit");
    }
    public static int io_uring_submit ( Addressable ring) {
        var mh$ = io_uring_submit$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_submit_and_wait$MH() {
        return RuntimeHelper.requireNonNull(constants$24.io_uring_submit_and_wait$MH,"io_uring_submit_and_wait");
    }
    public static int io_uring_submit_and_wait ( Addressable ring,  int wait_nr) {
        var mh$ = io_uring_submit_and_wait$MH();
        try {
            return (int)mh$.invokeExact(ring, wait_nr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_get_sqe$MH() {
        return RuntimeHelper.requireNonNull(constants$25.io_uring_get_sqe$MH,"io_uring_get_sqe");
    }
    public static MemoryAddress io_uring_get_sqe ( Addressable ring) {
        var mh$ = io_uring_get_sqe$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_buffers$MH() {
        return RuntimeHelper.requireNonNull(constants$25.io_uring_register_buffers$MH,"io_uring_register_buffers");
    }
    public static int io_uring_register_buffers ( Addressable ring,  Addressable iovecs,  int nr_iovecs) {
        var mh$ = io_uring_register_buffers$MH();
        try {
            return (int)mh$.invokeExact(ring, iovecs, nr_iovecs);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_unregister_buffers$MH() {
        return RuntimeHelper.requireNonNull(constants$25.io_uring_unregister_buffers$MH,"io_uring_unregister_buffers");
    }
    public static int io_uring_unregister_buffers ( Addressable ring) {
        var mh$ = io_uring_unregister_buffers$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_files$MH() {
        return RuntimeHelper.requireNonNull(constants$25.io_uring_register_files$MH,"io_uring_register_files");
    }
    public static int io_uring_register_files ( Addressable ring,  Addressable files,  int nr_files) {
        var mh$ = io_uring_register_files$MH();
        try {
            return (int)mh$.invokeExact(ring, files, nr_files);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_unregister_files$MH() {
        return RuntimeHelper.requireNonNull(constants$25.io_uring_unregister_files$MH,"io_uring_unregister_files");
    }
    public static int io_uring_unregister_files ( Addressable ring) {
        var mh$ = io_uring_unregister_files$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_files_update$MH() {
        return RuntimeHelper.requireNonNull(constants$25.io_uring_register_files_update$MH,"io_uring_register_files_update");
    }
    public static int io_uring_register_files_update ( Addressable ring,  int off,  Addressable files,  int nr_files) {
        var mh$ = io_uring_register_files_update$MH();
        try {
            return (int)mh$.invokeExact(ring, off, files, nr_files);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_eventfd$MH() {
        return RuntimeHelper.requireNonNull(constants$26.io_uring_register_eventfd$MH,"io_uring_register_eventfd");
    }
    public static int io_uring_register_eventfd ( Addressable ring,  int fd) {
        var mh$ = io_uring_register_eventfd$MH();
        try {
            return (int)mh$.invokeExact(ring, fd);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_eventfd_async$MH() {
        return RuntimeHelper.requireNonNull(constants$26.io_uring_register_eventfd_async$MH,"io_uring_register_eventfd_async");
    }
    public static int io_uring_register_eventfd_async ( Addressable ring,  int fd) {
        var mh$ = io_uring_register_eventfd_async$MH();
        try {
            return (int)mh$.invokeExact(ring, fd);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_unregister_eventfd$MH() {
        return RuntimeHelper.requireNonNull(constants$26.io_uring_unregister_eventfd$MH,"io_uring_unregister_eventfd");
    }
    public static int io_uring_unregister_eventfd ( Addressable ring) {
        var mh$ = io_uring_unregister_eventfd$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_probe$MH() {
        return RuntimeHelper.requireNonNull(constants$26.io_uring_register_probe$MH,"io_uring_register_probe");
    }
    public static int io_uring_register_probe ( Addressable ring,  Addressable p,  int nr) {
        var mh$ = io_uring_register_probe$MH();
        try {
            return (int)mh$.invokeExact(ring, p, nr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_personality$MH() {
        return RuntimeHelper.requireNonNull(constants$26.io_uring_register_personality$MH,"io_uring_register_personality");
    }
    public static int io_uring_register_personality ( Addressable ring) {
        var mh$ = io_uring_register_personality$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_unregister_personality$MH() {
        return RuntimeHelper.requireNonNull(constants$26.io_uring_unregister_personality$MH,"io_uring_unregister_personality");
    }
    public static int io_uring_unregister_personality ( Addressable ring,  int id) {
        var mh$ = io_uring_unregister_personality$MH();
        try {
            return (int)mh$.invokeExact(ring, id);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_register_restrictions$MH() {
        return RuntimeHelper.requireNonNull(constants$27.io_uring_register_restrictions$MH,"io_uring_register_restrictions");
    }
    public static int io_uring_register_restrictions ( Addressable ring,  Addressable res,  int nr_res) {
        var mh$ = io_uring_register_restrictions$MH();
        try {
            return (int)mh$.invokeExact(ring, res, nr_res);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_enable_rings$MH() {
        return RuntimeHelper.requireNonNull(constants$27.io_uring_enable_rings$MH,"io_uring_enable_rings");
    }
    public static int io_uring_enable_rings ( Addressable ring) {
        var mh$ = io_uring_enable_rings$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __io_uring_sqring_wait$MH() {
        return RuntimeHelper.requireNonNull(constants$27.__io_uring_sqring_wait$MH,"__io_uring_sqring_wait");
    }
    public static int __io_uring_sqring_wait ( Addressable ring) {
        var mh$ = __io_uring_sqring_wait$MH();
        try {
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle __io_uring_get_cqe$MH() {
        return RuntimeHelper.requireNonNull(constants$27.__io_uring_get_cqe$MH,"__io_uring_get_cqe");
    }
    public static int __io_uring_get_cqe ( Addressable ring,  Addressable cqe_ptr,  int submit,  int wait_nr,  Addressable sigmask) {
        var mh$ = __io_uring_get_cqe$MH();
        try {
            return (int)mh$.invokeExact(ring, cqe_ptr, submit, wait_nr, sigmask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_cq_advance$MH() {
        return RuntimeHelper.requireNonNull(constants$27.io_uring_cq_advance$MH,"io_uring_cq_advance");
    }
    public static void io_uring_cq_advance ( Addressable ring,  int nr) {
        var mh$ = io_uring_cq_advance$MH();
        try {
            mh$.invokeExact(ring, nr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_cqe_seen$MH() {
        return RuntimeHelper.requireNonNull(constants$27.io_uring_cqe_seen$MH,"io_uring_cqe_seen");
    }
    public static void io_uring_cqe_seen ( Addressable ring,  Addressable cqe) {
        var mh$ = io_uring_cqe_seen$MH();
        try {
            mh$.invokeExact(ring, cqe);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_sqe_set_data$MH() {
        return RuntimeHelper.requireNonNull(constants$28.io_uring_sqe_set_data$MH,"io_uring_sqe_set_data");
    }
    public static void io_uring_sqe_set_data ( Addressable sqe,  Addressable data) {
        var mh$ = io_uring_sqe_set_data$MH();
        try {
            mh$.invokeExact(sqe, data);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_cqe_get_data$MH() {
        return RuntimeHelper.requireNonNull(constants$28.io_uring_cqe_get_data$MH,"io_uring_cqe_get_data");
    }
    public static MemoryAddress io_uring_cqe_get_data ( Addressable cqe) {
        var mh$ = io_uring_cqe_get_data$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(cqe);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_sqe_set_flags$MH() {
        return RuntimeHelper.requireNonNull(constants$28.io_uring_sqe_set_flags$MH,"io_uring_sqe_set_flags");
    }
    public static void io_uring_sqe_set_flags ( Addressable sqe,  int flags) {
        var mh$ = io_uring_sqe_set_flags$MH();
        try {
            mh$.invokeExact(sqe, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_rw$MH() {
        return RuntimeHelper.requireNonNull(constants$28.io_uring_prep_rw$MH,"io_uring_prep_rw");
    }
    public static void io_uring_prep_rw ( int op,  Addressable sqe,  int fd,  Addressable addr,  int len,  long offset) {
        MemorySegment sqeSegment = NativeHelper.unsafePointConvertor(sqe.address());
        io_uring_sqe.opcode$set(sqeSegment, (byte) op);
        // 
//        io_uring_sqe.flags$get(sqeSegment,0);
        io_uring_sqe.ioprio$set(sqeSegment, (short) 0);
        io_uring_sqe.fd$set(sqeSegment, fd);
        io_uring_sqe.off$set(sqeSegment, offset);
        io_uring_sqe.addr$set(sqeSegment, addr.address().toRawLongValue());
        io_uring_sqe.len$set(sqeSegment, len);
        // 
//        io_uring_sqe.rw_flags$set(sqeSegment, 0);
//        io_uring_sqe.user_data$set(sqeSegment, 0);
        io_uring_sqe.__pad2$slice(sqeSegment).fill((byte) 0);
    }
    public static MethodHandle io_uring_prep_splice$MH() {
        return RuntimeHelper.requireNonNull(constants$28.io_uring_prep_splice$MH,"io_uring_prep_splice");
    }
    public static void io_uring_prep_splice ( Addressable sqe,  int fd_in,  long off_in,  int fd_out,  long off_out,  int nbytes,  int splice_flags) {
        var mh$ = io_uring_prep_splice$MH();
        try {
            mh$.invokeExact(sqe, fd_in, off_in, fd_out, off_out, nbytes, splice_flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_tee$MH() {
        return RuntimeHelper.requireNonNull(constants$28.io_uring_prep_tee$MH,"io_uring_prep_tee");
    }
    public static void io_uring_prep_tee ( Addressable sqe,  int fd_in,  int fd_out,  int nbytes,  int splice_flags) {
        var mh$ = io_uring_prep_tee$MH();
        try {
            mh$.invokeExact(sqe, fd_in, fd_out, nbytes, splice_flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_readv$MH() {
        return RuntimeHelper.requireNonNull(constants$29.io_uring_prep_readv$MH,"io_uring_prep_readv");
    }
    public static void io_uring_prep_readv ( Addressable sqe,  int fd,  Addressable iovecs,  int nr_vecs,  long offset) {
        io_uring_prep_rw(IORING_OP_READV(), sqe, fd,iovecs,nr_vecs,offset);
    }
    public static MethodHandle io_uring_prep_read_fixed$MH() {
        return RuntimeHelper.requireNonNull(constants$29.io_uring_prep_read_fixed$MH,"io_uring_prep_read_fixed");
    }
    public static void io_uring_prep_read_fixed ( Addressable sqe,  int fd,  Addressable buf,  int nbytes,  long offset,  int buf_index) {
        var mh$ = io_uring_prep_read_fixed$MH();
        try {
            mh$.invokeExact(sqe, fd, buf, nbytes, offset, buf_index);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_writev$MH() {
        return RuntimeHelper.requireNonNull(constants$29.io_uring_prep_writev$MH,"io_uring_prep_writev");
    }
    public static void io_uring_prep_writev ( Addressable sqe,  int fd,  Addressable iovecs,  int nr_vecs,  long offset) {
        io_uring_prep_rw(IORING_OP_WRITEV(), sqe, fd, iovecs, nr_vecs, offset);
    }
    public static MethodHandle io_uring_prep_write_fixed$MH() {
        return RuntimeHelper.requireNonNull(constants$29.io_uring_prep_write_fixed$MH,"io_uring_prep_write_fixed");
    }
    public static void io_uring_prep_write_fixed ( Addressable sqe,  int fd,  Addressable buf,  int nbytes,  long offset,  int buf_index) {
        var mh$ = io_uring_prep_write_fixed$MH();
        try {
            mh$.invokeExact(sqe, fd, buf, nbytes, offset, buf_index);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_recvmsg$MH() {
        return RuntimeHelper.requireNonNull(constants$29.io_uring_prep_recvmsg$MH,"io_uring_prep_recvmsg");
    }
    public static void io_uring_prep_recvmsg ( Addressable sqe,  int fd,  Addressable msg,  int flags) {
        var mh$ = io_uring_prep_recvmsg$MH();
        try {
            mh$.invokeExact(sqe, fd, msg, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_sendmsg$MH() {
        return RuntimeHelper.requireNonNull(constants$29.io_uring_prep_sendmsg$MH,"io_uring_prep_sendmsg");
    }
    public static void io_uring_prep_sendmsg ( Addressable sqe,  int fd,  Addressable msg,  int flags) {
        var mh$ = io_uring_prep_sendmsg$MH();
        try {
            mh$.invokeExact(sqe, fd, msg, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_poll_add$MH() {
        return RuntimeHelper.requireNonNull(constants$30.io_uring_prep_poll_add$MH,"io_uring_prep_poll_add");
    }
    public static void io_uring_prep_poll_add ( Addressable sqe,  int fd,  int poll_mask) {
        var mh$ = io_uring_prep_poll_add$MH();
        try {
            mh$.invokeExact(sqe, fd, poll_mask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_poll_remove$MH() {
        return RuntimeHelper.requireNonNull(constants$30.io_uring_prep_poll_remove$MH,"io_uring_prep_poll_remove");
    }
    public static void io_uring_prep_poll_remove ( Addressable sqe,  Addressable user_data) {
        var mh$ = io_uring_prep_poll_remove$MH();
        try {
            mh$.invokeExact(sqe, user_data);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle io_uring_prep_fsync$MH() {
        return RuntimeHelper.requireNonNull(constants$30.io_uring_prep_fsync$MH,"io_uring_prep_fsync");
    }
    public static void io_uring_prep_fsync ( Addressable sqe,  int fd,  int fsync_flags) {
//        io_uring_prep_rw(IORING_OP_FSYNC, sqe, fd, NULL, 0, 0);
//	sqe->fsync_flags = fsync_flags;
        io_uring_prep_rw(IORING_OP_FSYNC(), sqe, fd,MemoryAddress.NULL, 0,0);
        MemorySegment sqeSegment = MemorySegment.ofAddress(sqe.address(), io_uring_sqe.sizeof(), MemorySession.global());
        io_uring_sqe.fsync_flags$set(sqeSegment, fsync_flags);
    }
    public static MethodHandle io_uring_prep_nop$MH() {
        return RuntimeHelper.requireNonNull(constants$30.io_uring_prep_nop$MH,"io_uring_prep_nop");
    }
    public static void io_uring_prep_nop ( Addressable sqe) {
       io_uring_prep_rw(IORING_OP_NOP(),sqe,-1,MemoryAddress.NULL,0,0);
    }
}


